<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ebonyzhang&#39;s blog</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ebonyzhang.fun/"/>
  <updated>2019-01-21T09:47:47.966Z</updated>
  <id>https://ebonyzhang.fun/</id>
  
  <author>
    <name>ebonyzhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React前端开发总结</title>
    <link href="https://ebonyzhang.fun/2019/01/21/React%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://ebonyzhang.fun/2019/01/21/React前端开发总结/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-01-21T09:47:47.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>第一次使用react，还是习惯性的去找了合适的移动开发框架，直接在此基础上迭代开发。<br>优点是能快速及时上手一个项目，边开发应用边学习，能做出一个可以用，可以看的东西。<br>缺点是不能系统的学习，她的特性不能系统全面地掌握以及与之相关的技术底层能用但是原理不知其所以然。<br>整个项目虽然功能实现，但是是在一知半解状态做出来，边开发边解决问题，边重构迭代，react的优势并没有完全发挥出来。<br>希望系统学习之后能进行一次整体重构。</p></blockquote><h2 id="开发工具选择"><a href="#开发工具选择" class="headerlink" title="开发工具选择"></a>开发工具选择</h2><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h4 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h4><pre><code>使用这个就是因为以前用过，上手快，而且她快速，稳定，但是需要购买证书。</code></pre><h4 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h4><pre><code>速度较快，对超大文件读写速度飞快。</code></pre><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><pre><code>速度一般，更新快，占用资源较大。</code></pre><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>在 Chrome 上可以安装 React 开发者工具插件，这样就能在浏览器的开发控制台里看到 React 渲染出来的组件树，调试查看挺方便。</p><h2 id="React全家桶"><a href="#React全家桶" class="headerlink" title="React全家桶"></a>React全家桶</h2><blockquote><p>react + redux + react-router + less/sass + ES6 + webpack<br>react全家桶，react使用的标配，一个个做简单的说明。</p></blockquote><h3 id="构建开发环境demo"><a href="#构建开发环境demo" class="headerlink" title="构建开发环境demo"></a>构建开发环境demo</h3><p>使用create-react-app构建React开发环境，node以及npm已配置。<br>npm慢可以使用淘宝定制的cnpm，设置如下：</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org</code></pre><p>create-react-app demo安装</p><pre><code>create-react-app my-appcnpm install -g create-react-appcd my-app/npm start</code></pre><p>启动之后，<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a><br>接下来可以在此基础上，学习或者实验react相关…</p><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><pre><code>采用声明式，高效而且灵活的用来构建用户界面的框架。官方文档 https://react.docschina.org </code></pre><h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4><pre><code>react-dom提供操作DOM的扩展库。 </code></pre><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><pre><code>通过babel解析JSX语法代码转为纯JS语法代码的库。</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>   面向组件编程的(组件化编码开发)，最后得到标签代码，同时组件之间可以进行通信，数据传递也非常灵活。<br>关于组件通信方式，下面单独做了实验与总结。</p><p> <strong>组件通讯方式</strong></p><p>  <a href="https://blog.csdn.net/xingfuzhijianxia/article/details/86151243" target="_blank" rel="noopener">组件通信方式汇总</a></p><p><strong>其他</strong><br>组件上加上prop-types进行验证</p><blockquote><p>optionalArray: PropTypes.array,<br>optionalBool: PropTypes.bool,<br>optionalFunc: PropTypes.func,<br>optionalNumber: PropTypes.number,<br>optionalObject: PropTypes.object,<br>optionalString: PropTypes.string,<br>optionalSymbol: PropTypes.symbol</p></blockquote><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>虽然使用的框架中整合了redux，但是在使用中，为了赶进度仍然没有用，重构的时候也把这部分也加上了。</p><blockquote><p>只有遇到 React 实在解决不了的问题，你才需要 Redux 。</p></blockquote><p>redux简单实例。<br><a href="https://blog.csdn.net/xingfuzhijianxia/article/details/86523480" target="_blank" rel="noopener">Redux</a></p><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><blockquote><p>用于构建路由，主要有Router，IndexRoute，Route，Link，IndexLink这几个组件，以及hashHistory，browserHistory。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install --save react-router</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>项目部署的时候，原配置createHashHistory出现一片白问题，后来更换了createBrowserHistory，重新部署后可访问。<br>区别<br>browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；<br>hashHistory 是通过改变地址后面的 hash来改变浏览器的历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import createHistory from &apos;history/createBrowserHistory&apos;</span><br></pre></td></tr></table></figure><p>从 React Router 中导入 <router> <route></route></router></p><pre><code>import { BrowserRouter as Router, Route } from &apos;react-router-dom&apos;;    </code></pre><p><strong>react-router嵌套路由</strong></p><blockquote><p>Router包裹Route，<br>当url变化的时候，Router将会匹配到指定的路由，然后渲染路由绑定的组件。<br>Route用来显式地把路由映射到应用的组件结构上。 用path指定url，用component指定路由命中url后需要渲染的那个组件。</p></blockquote><p>如下：</p><pre><code>&lt;Router basename={AppCfg.app.BaseName}&gt; &lt;App&gt;   &lt;Route exact path=&quot;/&quot; component={CreateComponent(Default)} /&gt;             &lt;Route path=&quot;/home&quot; component={CreateComponent(Home)} /&gt;    &lt;Route path=&quot;/userinfo&quot; component={CreateComponent(UserInfo)} /&gt;  &lt;/App&gt;&lt;/Router&gt;</code></pre><blockquote><p>通过Provider将redux绑定到react，同时用Provider包裹路由，路由控制器就可以访问store。</p></blockquote><pre><code>&lt;AppContainer warnings={false}&gt;  &lt;Provider store={ApiClientStore} key=&quot;provider&quot;&gt;    &lt;Router history={history}&gt;      {RootElement}    &lt;/Router&gt;  &lt;/Provider&gt;&lt;/AppContainer&gt;</code></pre><p><strong>Switch</strong> </p><blockquote><p>Switch的特点是从上往下读,只要有一个匹配成功,就不会往下读(Switch是由包容性变成排他性的一个重要组件)    </p></blockquote><p>在具体页面跳转中使用switch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Switch &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">const &#123; location &#125; = route || &#123;&#125;;</span><br><span class="line">const &#123; key &#125; = location || &#123;&#125;;</span><br><span class="line">&lt;Switch key=&#123;key&#125; location=&#123;location&#125;&gt;</span><br><span class="line">  &#123;this.props.children&#125;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>其他</p><blockquote><p>React Router 提供一个 routerWillLeave 生命周期钩子，这使得 React 组件可以拦截正在发生的跳转，或在离开 route 前提示用户。routerWillLeave 返回值有以下两种：<br>return false 取消此次跳转<br>return 返回提示信息，在离开 route 前提示用户进行确认。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Lifecycle &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">const Home = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  // 假设 Home 是一个 route 组件，它可能会使用</span><br><span class="line">  // Lifecycle mixin 去获得一个 routerWillLeave 方法。</span><br><span class="line">  mixins: [ Lifecycle ],</span><br><span class="line"></span><br><span class="line">  routerWillLeave(nextLocation) &#123;</span><br><span class="line">    if (!this.state.isSaved)</span><br><span class="line">      return &apos;Your work is not saved! Are you sure you want to leave?&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Links</strong><br>Link在内部做了一个操作,把标签变成了a标签。</p><pre><code>&lt;Link to=&quot;user&quot; params={{userId: user.id}}&gt;touser&lt;/Link&gt;</code></pre><p><strong>Redirect组件(重定向)</strong><br>from(使用绝对路径)<br>exact(精准匹配)<br>to(跳转路径)</p><h3 id="less-sass"><a href="#less-sass" class="headerlink" title="less/sass"></a>less/sass</h3><p>本次开发中使用sass，由于使用了react-weui样式使用较少了。<br>SASS是一种CSS的开发工具，使CSS的开发，变得简单和可维护。<br>可以查看阮一峰老师关于此教程。<br><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p><strong>声明方式</strong><br>var 、function 、let 、const 、import、 class。</p><blockquote><p>ES6中明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量就会报错。</p></blockquote><p><strong>箭头函数</strong><br>相当于匿名函数，使用“箭头”（=&gt;）定义函数。<br><strong>无参箭头函数</strong><br>    setInterval(() =&gt; this.nextSlide(), 2000);<br><strong>一个参数箭头函数</strong></p><pre><code>x =&gt; {console.log(x*x)}</code></pre><p><strong>多个参数箭头函数</strong><br>   参数需要用括号()括起来</p><pre><code>&apos;use strict&apos; var arr = [10, 20, 1, 2]; arr.sort((x, y) =&gt; {   if(x-y&gt;0){       return 1;   }else{       return -1;   }});console.log(arr); // [1, 2, 10, 20]</code></pre><p><strong>可变参数</strong><br>…rest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">var i, sum = x + y;</span><br><span class="line"> for (i=0; i&lt;rest.length; i++) &#123;</span><br><span class="line">     sum += rest[i];</span><br><span class="line"> &#125;</span><br><span class="line"> return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>其他</strong></p><ol><li>this,箭头函数内部的this是词法作用域，由上下文确定。</li><li>函数体返回表达式的需要使用括号，例 x =&gt; ({ foo: x })</li></ol><blockquote><p>Es6箭头函数说明挺全也很简明<br><a href="https://www.cnblogs.com/snandy/p/4403111.html" target="_blank" rel="noopener">https://www.cnblogs.com/snandy/p/4403111.html</a></p></blockquote><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><blockquote><p>ES6 ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p></blockquote><p>重构时候原来的代码都有问题，前后空格、无效的代码以及分号等等各种问题。<br>一开始使用eslint确实会影响进度，但是对于规范代码以及语法有很好的引导，虽然麻烦点，最后的使用效果不错。<br>类似如下错误，根据提示修改即可。<br>(1) expected parenteses around arrow function argument having a body with curly braces arrow-parens<br>箭头函数参数周围的预期括号具有带大括号的主体<br>(2) Empty components are self-closing<br>组件内部空时，不需要自己关闭，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href=&#123;link&#125;&gt;</span><br><span class="line"> &lt;div  className=&quot;slider__slide&quot;</span><br><span class="line">    data-active=&#123;active&#125;</span><br><span class="line">    style=&#123;slideStyle&#125;</span><br><span class="line">    onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125;</span><br><span class="line">    onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125;</span><br><span class="line">    &#125;&gt;&lt;/div&gt; //此处</span><br><span class="line">&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&#123;link&#125;&gt;</span><br><span class="line"> &lt;div </span><br><span class="line">    className=&quot;slider__slide&quot;</span><br><span class="line">    data-active=&#123;active&#125;</span><br><span class="line">    style=&#123;slideStyle&#125;</span><br><span class="line">    onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125;</span><br><span class="line">    onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125;</span><br><span class="line">    &#125;/&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><blockquote><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p></blockquote><p>webpack与Gulp的区别</p><blockquote><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。<br>Webpack的处理速度更快更直接，能打包更多不同类型的文件</p></blockquote><p>这个不详细写了，要再实践总结下，但是这篇文章写得很好，值得学习。<br><a href="https://segmentfault.com/a/1190000006178770?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006178770?utm_source=tag-newest</a></p><h3 id="react-UI库"><a href="#react-UI库" class="headerlink" title="react UI库"></a>react UI库</h3><h4 id="Material-UI"><a href="#Material-UI" class="headerlink" title="Material-UI"></a>Material-UI</h4><blockquote><p>Material-UI是一个实现了Google’s Material Design设计规范的react组件库。</p></blockquote><h4 id="Ant-design"><a href="#Ant-design" class="headerlink" title="Ant-design"></a>Ant-design</h4><blockquote><p>蚂蚁金服开发的一个基于react的UI组件库</p></blockquote><h4 id="react-weui"><a href="#react-weui" class="headerlink" title="react-weui"></a>react-weui</h4><p>选择这个ui库本着做微信公众号开发，考虑到她能更好的兼容微信浏览器。</p><p><strong>1.安装</strong></p><pre><code>npm install weui@1.1.0 react-weui --save</code></pre><p><strong>2.使用</strong><br>在App.js中引入模块。</p><pre><code>import &apos;weui&apos;;import &apos;react-weui/build/packages/react-weui.css&apos;;</code></pre><p>实际使用中，import 相应的组件即可，以首页的tab切换页为例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Tab, TabBody, TabBar, TabBarItem, Article &#125; from &apos;react-weui&apos;;</span><br></pre></td></tr></table></figure><p>详细页面如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tab&gt;</span><br><span class="line"> &lt;TabBody&gt;</span><br><span class="line">    &lt;Article style=&#123;&#123; display: this.state.tab == 0 ? null : &apos;none&apos; &#125;&#125;&gt;</span><br><span class="line">      &lt;h1&gt;Page 1&lt;/h1&gt;</span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;h3&gt;1.1 Title&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;1111&lt;/p&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">    &lt;/Article&gt;</span><br><span class="line">    &lt;Article style=&#123;&#123; display: this.state.tab == 1 ? null : &apos;none&apos; &#125;&#125;&gt;</span><br><span class="line">      &lt;h1&gt;Page 2&lt;/h1&gt;</span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;h3&gt;2.1 Title&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;222&lt;/p&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">    &lt;/Article&gt;</span><br><span class="line">  &lt;/TabBody&gt;</span><br><span class="line">  &lt;TabBar&gt;</span><br><span class="line">    &lt;TabBarItem</span><br><span class="line">      active=&#123;this.state.tab == 0&#125;</span><br><span class="line">      icon=&#123;&lt;img src=&#123;this.state.urlmain&#125; alt=&quot;购票主页&quot; /&gt;&#125;</span><br><span class="line">      onClick=&#123;(e) =&gt; this.handleTab(e, 0)&#125;</span><br><span class="line">      label=&quot;主页&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;TabBarItem</span><br><span class="line">      active=&#123;this.state.tab == 1&#125;</span><br><span class="line">      icon=&#123;&lt;img src=&#123;this.state.urlmine&#125; alt=&quot;个人中心&quot; /&gt;&#125;</span><br><span class="line">      onClick=&#123;(e) =&gt; this.handleTab(e, 1)&#125;</span><br><span class="line">      label=&quot;个人中心&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/TabBar&gt;</span><br><span class="line">&lt;/Tab&gt;</span><br></pre></td></tr></table></figure><p>效果如下图</p><p><img src="https://img-blog.csdnimg.cn/20190116135946181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdmdXpoaWppYW54aWE=,size_16,color_FFFFFF,t_70" alt="初始化展示"></p><p>react-weui提供了一系列的组件，可以方便引入和使用，基本可以满足项目中的应用。</p><h3 id="集成react-s-alert"><a href="#集成react-s-alert" class="headerlink" title="集成react-s-alert"></a>集成react-s-alert</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install react-s-alert --save</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>在APP中引入样式与库文件。</p><pre><code>import Alert from &apos;react-s-alert&apos;;require(&apos;react-s-alert/dist/s-alert-default.css&apos;);require(&apos;react-s-alert/dist/s-alert-css-effects/genie.css&apos;);</code></pre><p>具体使用</p><pre><code>import Alert from &apos;react-s-alert&apos;;</code></pre><p>警告提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alert.warning(&apos;请选择添加购票人员&apos;, &#123;position: &apos;top&apos;,</span><br><span class="line">            offset: 40,onRouteClose: false, timeout: 1500&#125;);</span><br></pre></td></tr></table></figure></p><p>错误提示</p><pre><code>Alert.error(json.head.msg,     {position: &apos;top&apos;, offset: 40,onRouteClose: false, timeout: 2000,    onClose: function () {       Utility.toPage(&apos;order&apos;);    }});</code></pre><p>  onClose事件处理提示完之后的操作。</p><h3 id="react-confirm-alert"><a href="#react-confirm-alert" class="headerlink" title="react-confirm-alert"></a>react-confirm-alert</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-confirm-alert --save</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>引入相关样式与组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; confirmAlert &#125; from &apos;react-confirm-alert&apos;; // Import</span><br><span class="line">import &apos;react-confirm-alert/src/react-confirm-alert.css&apos; // Import css</span><br></pre></td></tr></table></figure></p><p>以退票提示为例，在退票操作之前，询问用户是否确认退票(或者常见的删除前确认提示)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">confirmAlert(&#123;</span><br><span class="line">  title: &apos;操作提示&apos;,</span><br><span class="line">   message: &apos;退票将产生[&apos;+fee+&apos;]元手续费，您确认执行退款操作吗?&apos;,</span><br><span class="line">   buttons: [</span><br><span class="line">     &#123;</span><br><span class="line">       label: &apos;确认&apos;,</span><br><span class="line">       onClick: () =&gt; this.refund() // 执行退票功能</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       label: &apos;取消&apos;,</span><br><span class="line">       onClick: () =&gt; console.log(&apos;取消了操作...&apos;)</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>关于提示的样式可以根据API来设置或者到源码里改改界面颜色。<br><strong>API</strong><br><a href="https://www.npmjs.com/package/react-confirm-alert" target="_blank" rel="noopener">https://www.npmjs.com/package/react-confirm-alert</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>做完这一个项目，对react以及相关组件了解了个大概，但现在看代码还是很杂很乱，看着闹心。<br>为了赶进度，一些react特性没有好好地应用，还是原始的JavaScript方式。<br>这次基本总结的同时也开始进行了项目重构，希望可以发挥react的优势，优化代码，优化调用以及实现方式等，争取年前完成。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>文献资料<br>从零搭建React全家桶框架教程<br><a href="https://github.com/brickspert/react-family" target="_blank" rel="noopener">https://github.com/brickspert/react-family</a><br><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">https://react.docschina.org/docs/thinking-in-react.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="React" scheme="https://ebonyzhang.fun/categories/React/"/>
    
    
      <category term="React" scheme="https://ebonyzhang.fun/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux</title>
    <link href="https://ebonyzhang.fun/2019/01/21/redux/"/>
    <id>https://ebonyzhang.fun/2019/01/21/redux/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-01-21T05:14:58.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p><blockquote><p>1.应用中所有的状态都是以一个对象树的形式存储在一个单一的store中；<br>2.当你想要改变应用的中的状态时，你就要dispatch一个action,这也是唯一的改变state的方法；<br>3.通过编写reducer来维护状态，返回新的state,不直接修改原来数据；</p></blockquote><p><strong>API</strong><br><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">https://www.redux.org.cn/</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install --save redux</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>阮一峰老师关于 Redux 入门教程说法很好：</p><blockquote><p>首先，并非所有的 React 应用程序都需要使用 Redux 的。  如果你不确定是否使用 Rudex ，那么你就是不需要的。<br>如果你遇到了无法解决的难题，那么 Rudex 可能就是你需要的东西。  Redux 的设计思想很简单，就两句话:</p><blockquote><p>**1. 整个系统是一个状态机，视图与状态是一一对应的 </p><ol start="2"><li>所有的状态，保存在一个对象里面**</li></ol></blockquote></blockquote><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>一个state对应着一个view，state改变，view跟着改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; getSlideData &#125; from &apos;actions/slides&apos;;</span><br><span class="line"></span><br><span class="line">@connect((state) =&gt; (&#123; slideData: state.slideData &#125;), &#123; getSlideData &#125;)</span><br></pre></td></tr></table></figure><pre><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></pre><p>官方API中说</p><blockquote><p>It does not modify the component class passed to it; instead, it returns a new, connected component class for you to use.</p></blockquote><p>mapStateToProps(state, ownProps) 方法允许我们将store中的数据作为props绑定到组件中，只要store更新了就会调用mapStateToProps方法<br>mapStateToProps返回的结果必须是object对象，该对象中的值将会更新到组件中。<br>mapDispatchToProps(dispatch, [ownProps]) 第二个参数允许我们将action作为props绑定到组件中，mapDispatchToProps希望你返回包含对应action的object对象</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>store是redux库中的createStore方法生成的对象，存储的是系统中的公有数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">const finalCreateStore = applyMiddleware(...middleware)(createStore);</span><br></pre></td></tr></table></figure><p><strong>applyMiddleware</strong>(科里化函数)主要是对redux的dispacth方法进行封装。</p><blockquote><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p></blockquote><p>用户的行为通过store.dispatch()来出发进行更改state</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>store.dispatch触发action,定义触发的动作。</p><blockquote><p>使用单独的模块或文件来定义 action type 常量并不是必须的，甚至根本不需要定义。对于小应用来说，使用字符串做 action type 更方便些。不过，在大型应用中把它们显式地定义成常量还是利大于弊的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const GET_SLIDES_LOADING = &apos;slides/loading&apos;;</span><br><span class="line">export const GET_SLIDES_SUCCESS = &apos;slides/success&apos;;</span><br><span class="line">export const GET_SLIDES_FAIL = &apos;slides/fail&apos;;</span><br><span class="line"></span><br><span class="line">export function getSlideData() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    types: [GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL],</span><br><span class="line">    promise: (client) =&gt; client.get(client.API.Slides, &#123; params: &#123; page: 1, rows: 10 &#125; &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们应该尽量减少在 action 中传递的数据</p></blockquote><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><blockquote><p>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store.</p></blockquote><p>reducer就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL &#125; from &apos;actions/slides&apos;;</span><br><span class="line"></span><br><span class="line">const initState = &#123;</span><br><span class="line">  isLoading: false,</span><br><span class="line">  slideData: &#123;&#125;,</span><br><span class="line">  errorMsg: &apos;&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function reducer(state = initState, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case GET_SLIDES_FAIL:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state, isLoading: false, slideData: null, errorMsg: &apos;请求错误啦&apos;,</span><br><span class="line">      &#125;;</span><br><span class="line">    case GET_SLIDES_LOADING:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state, isLoading: true, slideData: null, errorMsg: &apos;请求中...&apos;,</span><br><span class="line">      &#125;;</span><br><span class="line">    case GET_SLIDES_SUCCESS:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state, isLoading: false, slideData: action.result.text, errorMsg: &apos;获取成功&apos;,</span><br><span class="line">      &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次主要以一个首页轮播图的实现来实例整个流程。</p><p>Slider组件通过action把服务器响应(发生)请求送出来，获取轮播信息列表，reducer接收由store传入的请求action和旧的state(<code>(previousState, action) =&gt; newState</code>)，将返回结果按自己的格式更新到新的state返回，组件更新UI进行展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case GET_SLIDES_SUCCESS:</span><br><span class="line">     return &#123;</span><br><span class="line">       ...state, isLoading: false, slides: action.result, errorMsg: &apos;获取成功&apos;,</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure><p>组件里获取数据展示</p><pre><code>componentDidMount() { this.props.getSlideData().then((data) =&gt; {    const nd = JSON.parse(data);    if (nd.head.success) {      this.setState({        slides: nd.body.rows      });    }  }, (err) =&gt; {    console.log(err);  });  setInterval(() =&gt; this.nextSlide(), 2000);}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="React" scheme="https://ebonyzhang.fun/categories/React/"/>
    
    
      <category term="React" scheme="https://ebonyzhang.fun/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>基本指法</title>
    <link href="https://ebonyzhang.fun/2019/01/20/%E6%8C%87%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://ebonyzhang.fun/2019/01/20/指法汇总/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-01-21T03:13:06.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="义甲佩戴"><a href="#义甲佩戴" class="headerlink" title="义甲佩戴"></a>义甲佩戴</h2><p>老师说义甲相当于自己的指甲了要与自己的手指贴合，抹、托、打这三个指甲胶带缠绕靠近义甲底部。勾，大拇指缠绕比较特殊，要先把拇指放平，将义甲胶带部分与手指相平，指甲与手指的角度大概是120~130度差不多的位置。<br>    另外，缠绕胶带的时候最好整齐，可能有点强迫症，但也是一个端正的开始。</p><h2 id="基本手型"><a href="#基本手型" class="headerlink" title="基本手型"></a>基本手型</h2><p>右手自然弯曲，虎口处呈C状。弹奏时，指关节动而手不动，需要保持。<br>左手三指并拢，大指与小指延展，手背微弯。<br>无论左手还是右手整体都要是放松的姿势。</p><h2 id="基本指法"><a href="#基本指法" class="headerlink" title="基本指法"></a>基本指法</h2><h3 id="托"><a href="#托" class="headerlink" title="托"></a>托</h3><p>大指指关节向外弹弦。 </p><h3 id="抹"><a href="#抹" class="headerlink" title="抹"></a>抹</h3><p>食指指关节向内弹弦。</p><h3 id="勾"><a href="#勾" class="headerlink" title="勾"></a>勾</h3><p>中指指关节向内弹弦。</p><h3 id="打"><a href="#打" class="headerlink" title="打"></a>打</h3><p>名指指关节向内弹弦。</p><h3 id="劈"><a href="#劈" class="headerlink" title="劈"></a>劈</h3><p>大指指关节向内弹弦。<br>借助大指回拨的力度快速回拨。</p><h3 id="大撮"><a href="#大撮" class="headerlink" title="大撮"></a>大撮</h3><p>大指与中指，大指向外托，中指向里勾，同时弹奏两弦，一个8度。</p><h3 id="小撮"><a href="#小撮" class="headerlink" title="小撮"></a>小撮</h3><p>大指与食指，大指向外托，食指向里抹，同时弹奏两弦，在一个8度之内的都是小撮。</p><h3 id="上划音"><a href="#上划音" class="headerlink" title="上划音"></a>上划音</h3><p>右手先弹弦，左手按该弦。右手先动，左手再跟上，不要喧宾夺主。</p><h3 id="下划音"><a href="#下划音" class="headerlink" title="下划音"></a>下划音</h3><p>左手先按弦，右手弹奏。</p><h3 id="回滑音"><a href="#回滑音" class="headerlink" title="回滑音"></a>回滑音</h3><p>上滑音与下滑音结合。右手弹奏，左手快速按下弹起。</p><h3 id="定滑音"><a href="#定滑音" class="headerlink" title="定滑音"></a>定滑音</h3><p>规定音高的划音，1 12 6（12）之间有定滑音符号，可省略2音，直接跟上6。</p><h3 id="颤音"><a href="#颤音" class="headerlink" title="颤音"></a>颤音</h3><p>右手弹弦后，左手上下起伏按弦。<br>弹奏颤音时，右手先动，左手跟上，注意左手手型。</p><h3 id="持续颤音"><a href="#持续颤音" class="headerlink" title="持续颤音"></a>持续颤音</h3><p>用的较少，比颤音时长长一些。</p><h3 id="4和7"><a href="#4和7" class="headerlink" title="4和7"></a>4和7</h3><p>4音，按3音弦半拍，左手轻按弦。<br>7音，按6音弦一拍，左手稍重按弦。</p><h3 id="双托"><a href="#双托" class="headerlink" title="双托"></a>双托</h3><p>大指同时弹两弦。</p><h3 id="双抹"><a href="#双抹" class="headerlink" title="双抹"></a>双抹</h3><p>食指同时弹两弦。</p><h3 id="连托"><a href="#连托" class="headerlink" title="连托"></a>连托</h3><p>大指向外连续弹弦。</p><h3 id="连抹"><a href="#连抹" class="headerlink" title="连抹"></a>连抹</h3><p>食指向内连续弹弦。</p><h3 id="上刮奏"><a href="#上刮奏" class="headerlink" title="上刮奏"></a>上刮奏</h3><p>食指由低音到高音连续弹弦。</p><h3 id="下刮奏"><a href="#下刮奏" class="headerlink" title="下刮奏"></a>下刮奏</h3><p>大指由高音到低音连续弹弦。</p><h3 id="花指"><a href="#花指" class="headerlink" title="花指"></a>花指</h3><p><strong>板前花</strong> 不占时值，装饰性的花指。<br><strong>正版花</strong> 占一定的时值(变奏)</p><h3 id="8度双托"><a href="#8度双托" class="headerlink" title="8度双托"></a>8度双托</h3><p>是大撮加上连音一同弹奏，加上一个上划音。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>遥指，大指连续反复托劈。<br>琶音，单手或双手快速连续弹弦。<br>泛音<br>这三个或者其他未列的是尚未学习的，之后再学习过程中重新补充。</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>1.弹奏力度不够，跟老师对比来的时候，明显感觉自己弹出的音太绵软。每个指法在练习的时候都有这个问题，需要多进行复盘，也可能吃多点就好了哈哈。<br>2.一些按弦略有迟疑，在左手下滑音练习时，起手会慢。<br>3.左手在按弦时，习惯性的单指(这是古琴的指法)，要三指并拢，大指与小指延展，手背微弯，整体是个放松的姿势。<br>4.劈以及连托弹奏时，手型不自觉的会变动，同时还有力度问题，需要强化练习恢复过来。<br>5.整体上手指灵活度还是不够，需要每日练习。<br>6.指法符号要与指法对应起来。看到书上的指法符号手指能即时弹奏出来，现在存在看到一个符号要想半天才弹出来的情况。</p><p>最后，下次再去上课的时候注意老师弹奏时候的指法，先去模仿，再去练习，最后形成与自己契合的指法。</p><blockquote><p>虽然课后做了笔记，总觉得之后会有丢失，这周重新做下汇总，把没想到的再补充完善下，基本指法比较简略，随着之后的学习再补充完善吧。</p></blockquote><hr><blockquote><p>得良师春风化雨，有益友万事顺风。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="古筝" scheme="https://ebonyzhang.fun/categories/%E5%8F%A4%E7%AD%9D/"/>
    
    
      <category term="古筝" scheme="https://ebonyzhang.fun/tags/%E5%8F%A4%E7%AD%9D/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://ebonyzhang.fun/2019/01/11/Git/"/>
    <id>https://ebonyzhang.fun/2019/01/11/Git/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-21T03:12:35.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></p><p>将缓存区内容添加到本地仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;注释&apos;</span><br></pre></td></tr></table></figure></p><p>推送到远程服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>添加到暂存区时，出现很多untrack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure></p><p>之后，重新进行了添加，有个问题是将一些不需要的模块也上传了上去，于是做了清理以及重新添加提交等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><p>查看当前仓库中文件的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>如果没有问题，进行提交到本地仓库，最后推送到远程服务器。</p><p>查看当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>更新代码到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>此次将博客维护在了github上方便多台电脑操作，node_modules模块实在没必要上传维护，创建.gitignore文件,将不需要的文件夹配置在里面，<br>被ignore的文件肯定不会被标上untracked，上面的问题就是显示红字untracked。<br>在其他电脑上使用npm重新安装就可以，每次在更新博客时，要重新pull。</p><p>.gitignore文件配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><hr><blockquote><p>所有事情到最后都会是好事，如果还不是，那她还没到最后——约翰*列侬 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Git" scheme="https://ebonyzhang.fun/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ebonyzhang.fun/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>React组件通信方式总结</title>
    <link href="https://ebonyzhang.fun/2019/01/09/React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <id>https://ebonyzhang.fun/2019/01/09/React组件通信方式汇总/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-20T12:56:01.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="React组件通信方式"><a href="#React组件通信方式" class="headerlink" title="React组件通信方式"></a>React组件通信方式</h2><h3 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h3><p>  父组件更新组件状态，通过props传递给子组件，子组件得到后进行更新。<br> Timer 是倒计时子组件，集成在了OrderPay父组件里，父组件向子组件传订单数据参数order对象。如下代码：</p><pre><code>&lt;Timer order={order} /&gt; //倒计时组件</code></pre><p>在子组件里直接通过props获取父组件传递过来的参数，如下：</p><pre><code>let order = this.props.order;//订单详情</code></pre><h3 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h3><p>  子组件更新组件状态，通过回调函数的方式传递给父组件。<br>  子组件调用父组件通过props传给它的函数更新父组件state，进而完成子组件向父组件的通讯。</p><p><strong>先看父组件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line"></span><br><span class="line">//导入子组件</span><br><span class="line">import Child from &apos;./child.js&apos;; </span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      msg: &apos;父组件初始msg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //父组件回调函数，更新state，进而更新父组件。</span><br><span class="line">  callback=(msg)=&gt;&#123;</span><br><span class="line">    // setState方法,修改msg参数,值是由子组件传过来。</span><br><span class="line">    this.setState(&#123;msg&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;p&gt;子组件传值实验: &#123;this.state.msg&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Child callback=&#123;this.callback&#125; &gt;&lt;/Child&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p><strong>再看子组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component&#123;</span><br><span class="line">constructor(props)&#123;</span><br><span class="line">      super(props);</span><br><span class="line">    this.state=&#123;</span><br><span class="line">    msg: &apos;子组件msg传值&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过props调用回调函数传值</span><br><span class="line">    trans=()=&gt;&#123;</span><br><span class="line">        this.props.callback(this.state.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.trans&#125;&gt;激发trans事件，传值给父组件&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Child;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="https://img-blog.csdnimg.cn/2019010910104894.png" alt="父组件初始展示"></p><p><img src="https://img-blog.csdnimg.cn/20190109101112169.png" alt="子组件更新后展示"></p><h3 id="跨级组件间通信"><a href="#跨级组件间通信" class="headerlink" title="跨级组件间通信"></a>跨级组件间通信</h3><p>  举个例子react-redux的<provider>，也是通过Context提供一个全局态的store。还有用户信息的使用，也可以通过context中传递数据。</provider></p><p>  通过props或state传值比较麻烦，context提供了一种组件之间共享数据的方式，可以避免数据在组件树上逐层传递，也就是用Context来实现跨层级的组件数据传递。</p><p>这篇文章写得非常好，看完就能理解context，上手实验更能理解透彻，毕竟最后都要应用起来。<br><a href="https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><blockquote><p>Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。</p></blockquote><p><strong>生产者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line">import CppComponent from &apos;./Cpp.js&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //生产者</span><br><span class="line">  //Context生产者，通过静态属性childContextTypes声明提供给子组件的Context对象的属性，</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //实例getChildContext方法，返回Context对象</span><br><span class="line">  getChildContext () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      propA: &apos;propA&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;BppComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BppComponent extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;CppComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p><strong>消费者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 第三层有A（生产者）层直接传递数据到此层C（消费者）</span><br><span class="line"> */</span><br><span class="line">class CppComponent extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">   //消费者</span><br><span class="line">   //子组件需要通过一个静态属性contextTypes声明后，才可以访问父组件Context对象的属性</span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;p&gt;从生产者传递过来的属性A：&#123;this.context.propA&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    ) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CppComponent;</span><br></pre></td></tr></table></figure><p>react升级后，Context的新API做了变更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Context&lt;T&gt; = &#123;</span><br><span class="line">     Provider: Provider&lt;T&gt;,</span><br><span class="line">     Consumer: Consumer&lt;T&gt;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line">import CppComponent from &apos;./Cpp.js&apos;;</span><br><span class="line"></span><br><span class="line">const CommContext = React.createContext(&#123;</span><br><span class="line">  a: &apos;aaaaa&apos;,</span><br><span class="line">  b: &apos;bbbbb&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  //父组件</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;    </span><br><span class="line">    return(</span><br><span class="line">      &lt;CommContext.Provider&gt;</span><br><span class="line">        &lt;BppComponent /&gt;</span><br><span class="line">      &lt;/CommContext.Provider&gt;</span><br><span class="line">    )  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BppComponent extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CppComponent&gt;context跨层级传参实验&lt;/CppComponent&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过静态方法React.createContext()创建一个Context对象，</span><br><span class="line"> * 这个Context对象包含两个组件，&lt;Provider /&gt;和&lt;Consumer /&gt;</span><br><span class="line"> */</span><br><span class="line">const CommContext = React.createContext(&#123;</span><br><span class="line">  a: &apos;newaaaaa&apos;,</span><br><span class="line">  b: &apos;newbbbbb&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 第三层有A（生产者）层直接传递数据到此层C（消费者）</span><br><span class="line"> */</span><br><span class="line">class CppComponent extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  //消费者</span><br><span class="line">  render () &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;CommContext.Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          context =&gt; (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &#123;this.props.children&#125; &lt;br/&gt;</span><br><span class="line">              参数a: &#123;context.a&#125; &lt;br/&gt;</span><br><span class="line">              参数b: &#123;context.b&#125; </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">      &lt;/CommContext.Consumer&gt;</span><br><span class="line">    ) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CppComponent;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="https://img-blog.csdnimg.cn/20190109140726790.png" alt="context越级传参"></p><p><strong>其他使用方式</strong><br>构造方法：</p><pre><code>constructor(props, context)</code></pre><p>生命周期：</p><pre><code>componentWillReceiveProps(nextProps, nextContext)shouldComponentUpdate(nextProps, nextState, nextContext)componetWillUpdate(nextProps, nextState, nextContext)</code></pre><blockquote><p>注入式的组件，类似背景、语言这种控制全局的变量，可使用context。</p></blockquote><h3 id="非嵌套组件间通信"><a href="#非嵌套组件间通信" class="headerlink" title="非嵌套组件间通信"></a>非嵌套组件间通信</h3><blockquote><p>非嵌套组件: 就是没有任何包含关系的组件,包括兄弟组件以及不再同一个父级的非兄弟组件。<br>使用事件订阅，即一个发布者，一个或多个订阅者。</p></blockquote><h4 id="安装event"><a href="#安装event" class="headerlink" title="安装event"></a>安装event</h4><pre><code>npm install event -save</code></pre><h4 id="新建Evt-js，导入events"><a href="#新建Evt-js，导入events" class="headerlink" title="新建Evt.js，导入events"></a>新建Evt.js，导入events</h4><pre><code>import {EventEmitter} from &apos;events&apos;;export default new EventEmitter();   </code></pre><h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><p>通过emit事件触发方法，发布订阅消息给订阅者。<br><strong>发布者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line">import Custom1 from &apos;./Custom1.js&apos;;</span><br><span class="line">import Custom2 from &apos;./Custom2.js&apos;;</span><br><span class="line">import emitter from &apos;./Evt.js&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    //emit事件触发方法,过事件名称找对应的事件处理函数callCustom，将事件处理函数作为参数传入</span><br><span class="line">    emitter.emit(&apos;callCustom&apos;, &apos;Hello 我来发消息了&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;    </span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button onClick = &#123;this.handleClick&#125;&gt;点击发布事件&lt;/button&gt;</span><br><span class="line">        &lt;Custom1 /&gt;</span><br><span class="line">        &lt;Custom2 /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">     </span><br><span class="line">    )  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><h4 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h4><p>Custom1 和 Custom2<br>通过emitter.<strong>addListener</strong>(事件名称,函数名)方法，进行事件监听(订阅)。<br>通过emitter.<strong>removeListener</strong>(事件名称,函数名)方法 ，进行事件销毁(取消订阅)</p><p><strong>订阅者1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import emitter from &apos;./Evt.js&apos;;</span><br><span class="line"></span><br><span class="line">class Custom1 extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state= &#123;</span><br><span class="line">      msg:&apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件</span><br><span class="line">    emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg: &apos;Custom1收到消息--&apos;+msg</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount () &#123; //组件销毁前移除事件监听</span><br><span class="line">    emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg: &apos;Custom1即将销毁此消息--&apos;+ msg</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //订阅者1消息显示</span><br><span class="line">  render () &#123;</span><br><span class="line">     return(&lt;p style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;</span><br><span class="line">        &#123;this.state.msg&#125;</span><br><span class="line">      &lt;/p&gt;) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Custom1;</span><br></pre></td></tr></table></figure><p><strong>订阅者2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import emitter from &apos;./Evt.js&apos;;</span><br><span class="line"></span><br><span class="line">class Custom2 extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state= &#123;</span><br><span class="line">      msg:&apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件</span><br><span class="line">    emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg: &apos;Custom2收到消息--&apos;+msg</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount () &#123; //组件销毁前移除事件监听</span><br><span class="line">    emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg: &apos;Custom2即将销毁此消息--&apos;+ msg</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //订阅者2消息显示</span><br><span class="line">  render () &#123;</span><br><span class="line">    return(&lt;p style=&#123;&#123;color:&apos;blue&apos;&#125;&#125;&gt;&#123;this.state.msg&#125;&lt;/p&gt;) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Custom2;</span><br></pre></td></tr></table></figure><p>运行效果如下：<br>发布者发布消息前<br><img src="https://img-blog.csdnimg.cn/20190109154003970.png" alt="发布者发布消息前"><br>订阅者接收消息后<br><img src="https://img-blog.csdnimg.cn/20190109154036101.png" alt="订阅者接收消息后"></p><blockquote><p>文献资料<br>非嵌套组件通信详解<br><a href="https://blog.csdn.net/bbgdebb/article/details/79006277" target="_blank" rel="noopener">https://blog.csdn.net/bbgdebb/article/details/79006277</a><br>node.js源码解析-events<br><a href="https://blog.csdn.net/leoleocs/article/details/50162065" target="_blank" rel="noopener">https://blog.csdn.net/leoleocs/article/details/50162065</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="React" scheme="https://ebonyzhang.fun/categories/React/"/>
    
    
      <category term="React" scheme="https://ebonyzhang.fun/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>接口问题以及解决方案汇总</title>
    <link href="https://ebonyzhang.fun/2019/01/05/%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
    <id>https://ebonyzhang.fun/2019/01/05/接口问题以及解决方案汇总/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-01-21T03:12:10.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="接口问题以及解决方案汇总"><a href="#接口问题以及解决方案汇总" class="headerlink" title="接口问题以及解决方案汇总"></a>接口问题以及解决方案汇总</h2><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><blockquote><p>省内接口转为全国统一接口，作为接口中转，主要是承上启下的作用。<br>保持前端请求以及参数不变的情况下，业务逻辑集中处理；<br>提供给第三方或者四方?!调用；<br>当接口变更时只更改当前接口项目即可。</p></blockquote><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><code>java.net.URISyntaxException //Http Get请求报出此次错误。</code></p><p><strong>问题原因</strong>：</p><p><em>第三方接口需要将参数部分进行编码后提交。 原接口进行了编码传到中转接口这里仍然需要获取并重新编码传给第三方。</em></p><p><strong>解决办法</strong>：</p><p> 重新进行编码<br><code>URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;)</code></p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><pre><code>关于接口请求参数JSON格式的重新封装问题。</code></pre><p><strong>问题原因</strong>：</p><p><em>请求参数param是json格式的，接收过来的参数不能直接toJSONString，编码后传给第三方</em></p><p><strong>解决办法</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (map.containsKey(&quot;param&quot;)) &#123;</span><br><span class="line">JSONObject param = JSONObject.parseObject((String)map.get(&quot;param&quot;));</span><br><span class="line">url = url + &quot;&amp;param=&quot; + URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>针对接口调用做简单的记录，方便今后查看。<br>其实最好的框架是适合项目本身的，与高级或所谓低端无关，越是简单的反而更能解决问题，提升效率。</p></blockquote><hr><blockquote><p>是非入耳君须忍，半作痴呆半作聋。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="接口" scheme="https://ebonyzhang.fun/categories/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="接口" scheme="https://ebonyzhang.fun/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题与配置优化</title>
    <link href="https://ebonyzhang.fun/2019/01/03/Hexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    <id>https://ebonyzhang.fun/2019/01/03/Hexo主题与配置优化/</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-01-20T12:55:15.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a>next主题配置</h2><pre><code>https://hexo.io/themes/主题选择，本文是next主题安装配置以及优化。</code></pre><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>在博客根目录，打开git bash, git clone https://github.com/theme-next/hexo-theme-next themes / next 安装完毕后在站点目录下themes文件夹生成next主题文件夹。</code></pre><h3 id="站点开启主题"><a href="#站点开启主题" class="headerlink" title="站点开启主题"></a>站点开启主题</h3><pre><code>在站点根目录设置主题：next  </code></pre><p> <img src="https://img-blog.csdnimg.cn/20190103115249653.png" alt="在这里插入图片描述"></p><h3 id="next主题中文设置"><a href="#next主题中文设置" class="headerlink" title="next主题中文设置"></a>next主题中文设置</h3><pre><code>站点配置文件_config.ymllanguage: zh-Hans  </code></pre><h3 id="Scheme-外观设置"><a href="#Scheme-外观设置" class="headerlink" title="Scheme 外观设置"></a>Scheme 外观设置</h3><pre><code>这里选择了双栏PiscesMuse黑白主调，大量留白。Mist是Muse的紧凑版本，整洁有序的单栏外观Gemini左侧网站信息及目录，块+片段结构布局</code></pre><p> <img src="https://img-blog.csdnimg.cn/2019010314322624.png" alt="在这里插入图片描述"></p><h3 id="新增菜单设置"><a href="#新增菜单设置" class="headerlink" title="新增菜单设置"></a>新增菜单设置</h3><pre><code>第一步：hexo new page &apos;name&apos; # name分别为tags、categories、about具体生成如下：hexo new page &apos;tags&apos; #创建tags标签子目录hexo new page &apos;categories&apos; #创建categories分类子目录hexo new page &apos;about&apos; #创建about关于子目录第二步：修改这tags和categories文件夹中的index.md，设置如下：</code></pre><p>  <img src="https://img-blog.csdnimg.cn/20190103142950806.png" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20190103142935429.png" alt="在这里插入图片描述"></p><h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><h3 id="公益404"><a href="#公益404" class="headerlink" title="公益404"></a>公益404</h3><pre><code>将公益404一份在网页丢失时候。另外还放在了关于里面。在网页丢失时候：第一步：创建404页面hexo new page 404 ; 第二步：在站点source文件夹下创建404.html，将如下代码粘贴进去，保存！</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;]\</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;404&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><pre><code>注册一个网易账号，生成一个自己的一个歌单，加入自己喜欢的音乐。在网易云插件里，嵌入iframe(可以根据自己设定调整，然后复制代码)hexo配置，在next主题下/layout/_macro/sidebar.swig文件里添加复制的代码即可。配置显示在左侧栏中</code></pre><h3 id="点击桃心"><a href="#点击桃心" class="headerlink" title="点击桃心"></a>点击桃心</h3><pre><code>第一步： 在 /themes/next/source/js/src 文件夹下创建 clklove.js 将如下代码粘贴进去，保存！</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure><pre><code>第二步：在主题文件夹下 \themes\next\layout\_layout.swig文件末尾，引入创建的js文件，如下：</code></pre><p>   <img src="https://img-blog.csdnimg.cn/20190103141814805.png" alt="在这里插入图片描述"></p><h3 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h3><pre><code>第一步：引入文件</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><pre><code>第二步：在next主题配置文件_config.yml设置canvas_nest: true</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code>第一步：安装插件npm install hexo-generator-searchdb --save第二步：站点配置文件修改</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><pre><code>第三步：主题配置文件修改</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure><h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><pre><code>第一步：安装插件npm install hexo-generator-feed第二步：站点配置_config.yml配置文件添加以下代码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><pre><code>第三步：主题配置在themes目录下的_config.yml配置如下rss: /atom.xml</code></pre><hr><blockquote><p>进学致和，行方思远。——字严 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="hexo" scheme="https://ebonyzhang.fun/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ebonyzhang.fun/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo基础</title>
    <link href="https://ebonyzhang.fun/2018/12/29/%E4%BD%BF%E7%94%A8hexo+GitHub+%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <id>https://ebonyzhang.fun/2018/12/29/使用hexo+GitHub+阿里云搭建个人网站/</id>
    <published>2018-12-28T16:00:00.000Z</published>
    <updated>2019-01-21T03:12:54.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h2><pre><code>https://hexo.io/zh-cn/docs/hexo官方文档连接地址</code></pre><h2 id="安装node和git"><a href="#安装node和git" class="headerlink" title="安装node和git"></a>安装node和git</h2><p> 请自行从网上查找适合自己系统和版本进行安装。</p><h3 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h3><pre><code>https://nodejs.org/zh-cn/自行配置Node.js环境</code></pre><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><pre><code>git 下载 https://git-scm.com/download</code></pre><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="安装与启动部署"><a href="#安装与启动部署" class="headerlink" title="安装与启动部署"></a>安装与启动部署</h3><pre><code>npm install -g hexo-cli  //hexo插件安装hexo init blob //初始化hexo文件夹blobcd blobnpm installhexo generate //可简写为hexo ghexo sever //可简写为hexo s</code></pre><p><img src="https://img-blog.csdnimg.cn/20181229161737386.png" alt="启动服务"><br>    访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> </p><pre><code>Hello World </code></pre><h3 id="上传GitHub"><a href="#上传GitHub" class="headerlink" title="上传GitHub"></a>上传GitHub</h3><h3 id="安装github插件"><a href="#安装github插件" class="headerlink" title="安装github插件"></a>安装github插件</h3><pre><code>npm install hexo-deployer-git --save //安装插件</code></pre><h3 id="github注册以及配置"><a href="#github注册以及配置" class="headerlink" title="github注册以及配置"></a>github注册以及配置</h3><pre><code>(1) 没有GitHub的访问以下网站注册一个账户    https://github.com(2) 建立资源库，例如blob(3) 在hexo中配置该仓库地址</code></pre><h3 id="本地站点github相关配置"><a href="#本地站点github相关配置" class="headerlink" title="本地站点github相关配置"></a>本地站点github相关配置</h3><pre><code>找到hexo安装目录blob文件夹，在站点配置文件_config.yml里修改如下配置：deploy:    type: git  repository: git@github.com:你的Github账户/仓库.git  branch: master</code></pre><h3 id="部署静态文件到github"><a href="#部署静态文件到github" class="headerlink" title="部署静态文件到github"></a>部署静态文件到github</h3><pre><code>通过git bash部署到github上hexo deploy //可简写为 hexo d </code></pre><h3 id="域名关联gitpage"><a href="#域名关联gitpage" class="headerlink" title="域名关联gitpage"></a>域名关联gitpage</h3><pre><code>(1) 阿里云域名配置    在阿里云域名模块解析域名配置        将记录类型设置为CNAME；        记录值修改为 yourname.github.io    在hexo安装目录中找到source文件夹        新建CNAME文件，没有后缀。        将你的域名放在新建的CNAME文件中。(2) GitHub Pages配置    在blob资源仓库中Setting里，  下拉找到GitHub Pages部分    配置 Custom domain，将你的域名填写进去，点击save。</code></pre><p><img src="https://img-blog.csdnimg.cn/20181229170710433.png" alt="github pages"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>//清除缓存hexo clean //生成静态网页hexo g//部署到githexo d//本地服务启动hexo s</code></pre><blockquote><p>比较简略，大体流程就是这些，个人觉得在自己动手查找过程会有更多的收获。</p></blockquote><hr><p>纸上得来终觉浅，觉知此事要躬行。——陆游</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="hexo" scheme="https://ebonyzhang.fun/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ebonyzhang.fun/tags/hexo/"/>
    
  </entry>
  
</feed>
