<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React前端开发总结]]></title>
    <url>%2F2019%2F01%2F21%2FReact%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第一次使用react，还是习惯性的去找了合适的移动开发框架，直接在此基础上迭代开发。优点是能快速及时上手一个项目，边开发应用边学习，能做出一个可以用，可以看的东西。缺点是不能系统的学习，她的特性不能系统全面地掌握以及与之相关的技术底层能用但是原理不知其所以然。整个项目虽然功能实现，但是是在一知半解状态做出来，边开发边解决问题，边重构迭代，react的优势并没有完全发挥出来。希望系统学习之后能进行一次整体重构。 开发工具选择开发工具Sublime Text 3使用这个就是因为以前用过，上手快，而且她快速，稳定，但是需要购买证书。 Vscode速度较快，对超大文件读写速度飞快。 Atom速度一般，更新快，占用资源较大。 调试工具在 Chrome 上可以安装 React 开发者工具插件，这样就能在浏览器的开发控制台里看到 React 渲染出来的组件树，调试查看挺方便。 React全家桶 react + redux + react-router + less/sass + ES6 + webpackreact全家桶，react使用的标配，一个个做简单的说明。 构建开发环境demo使用create-react-app构建React开发环境，node以及npm已配置。npm慢可以使用淘宝定制的cnpm，设置如下： npm install -g cnpm --registry=https://registry.npm.taobao.org npm config set registry https://registry.npm.taobao.org create-react-app demo安装 create-react-app my-app cnpm install -g create-react-app cd my-app/ npm start 启动之后，http://localhost:3000/接下来可以在此基础上，学习或者实验react相关… react采用声明式，高效而且灵活的用来构建用户界面的框架。 官方文档 https://react.docschina.org 虚拟domreact-dom提供操作DOM的扩展库。 JSX通过babel解析JSX语法代码转为纯JS语法代码的库。 组件 面向组件编程的(组件化编码开发)，最后得到标签代码，同时组件之间可以进行通信，数据传递也非常灵活。关于组件通信方式，下面单独做了实验与总结。 组件通讯方式 组件通信方式汇总 其他组件上加上prop-types进行验证 optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol redux虽然使用的框架中整合了redux，但是在使用中，为了赶进度仍然没有用，重构的时候也把这部分也加上了。 只有遇到 React 实在解决不了的问题，你才需要 Redux 。 redux简单实例。Redux react-router 用于构建路由，主要有Router，IndexRoute，Route，Link，IndexLink这几个组件，以及hashHistory，browserHistory。 安装npm install --save react-router 使用项目部署的时候，原配置createHashHistory出现一片白问题，后来更换了createBrowserHistory，重新部署后可访问。区别browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；hashHistory 是通过改变地址后面的 hash来改变浏览器的历史记录。 1import createHistory from &apos;history/createBrowserHistory&apos; 从 React Router 中导入 import { BrowserRouter as Router, Route } from &apos;react-router-dom&apos;; react-router嵌套路由 Router包裹Route，当url变化的时候，Router将会匹配到指定的路由，然后渲染路由绑定的组件。Route用来显式地把路由映射到应用的组件结构上。 用path指定url，用component指定路由命中url后需要渲染的那个组件。 如下： &lt;Router basename={AppCfg.app.BaseName}&gt; &lt;App&gt; &lt;Route exact path=&quot;/&quot; component={CreateComponent(Default)} /&gt; &lt;Route path=&quot;/home&quot; component={CreateComponent(Home)} /&gt; &lt;Route path=&quot;/userinfo&quot; component={CreateComponent(UserInfo)} /&gt; &lt;/App&gt; &lt;/Router&gt; 通过Provider将redux绑定到react，同时用Provider包裹路由，路由控制器就可以访问store。 &lt;AppContainer warnings={false}&gt; &lt;Provider store={ApiClientStore} key=&quot;provider&quot;&gt; &lt;Router history={history}&gt; {RootElement} &lt;/Router&gt; &lt;/Provider&gt; &lt;/AppContainer&gt; Switch Switch的特点是从上往下读,只要有一个匹配成功,就不会往下读(Switch是由包容性变成排他性的一个重要组件) 在具体页面跳转中使用switch 1234567import &#123; Switch &#125; from &apos;react-router-dom&apos;;const &#123; location &#125; = route || &#123;&#125;;const &#123; key &#125; = location || &#123;&#125;;&lt;Switch key=&#123;key&#125; location=&#123;location&#125;&gt; &#123;this.props.children&#125;&lt;/Switch&gt; 其他 React Router 提供一个 routerWillLeave 生命周期钩子，这使得 React 组件可以拦截正在发生的跳转，或在离开 route 前提示用户。routerWillLeave 返回值有以下两种：return false 取消此次跳转return 返回提示信息，在离开 route 前提示用户进行确认。 12345678910111213141516import &#123; Lifecycle &#125; from &apos;react-router&apos;const Home = React.createClass(&#123; // 假设 Home 是一个 route 组件，它可能会使用 // Lifecycle mixin 去获得一个 routerWillLeave 方法。 mixins: [ Lifecycle ], routerWillLeave(nextLocation) &#123; if (!this.state.isSaved) return &apos;Your work is not saved! Are you sure you want to leave?&apos; &#125;, // ...&#125;) LinksLink在内部做了一个操作,把标签变成了a标签。 &lt;Link to=&quot;user&quot; params={{userId: user.id}}&gt;touser&lt;/Link&gt; Redirect组件(重定向)from(使用绝对路径)exact(精准匹配)to(跳转路径) less/sass本次开发中使用sass，由于使用了react-weui样式使用较少了。SASS是一种CSS的开发工具，使CSS的开发，变得简单和可维护。可以查看阮一峰老师关于此教程。http://www.ruanyifeng.com/blog/2012/06/sass.html ES6声明方式var 、function 、let 、const 、import、 class。 ES6中明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量就会报错。 箭头函数相当于匿名函数，使用“箭头”（=&gt;）定义函数。无参箭头函数 setInterval(() =&gt; this.nextSlide(), 2000);一个参数箭头函数 x =&gt; {console.log(x*x)} 多个参数箭头函数 参数需要用括号()括起来 &apos;use strict&apos; var arr = [10, 20, 1, 2]; arr.sort((x, y) =&gt; { if(x-y&gt;0){ return 1; }else{ return -1; } }); console.log(arr); // [1, 2, 10, 20] 可变参数…rest1234567(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 其他 this,箭头函数内部的this是词法作用域，由上下文确定。 函数体返回表达式的需要使用括号，例 x =&gt; ({ foo: x }) Es6箭头函数说明挺全也很简明https://www.cnblogs.com/snandy/p/4403111.html ESLint ES6 ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 重构时候原来的代码都有问题，前后空格、无效的代码以及分号等等各种问题。一开始使用eslint确实会影响进度，但是对于规范代码以及语法有很好的引导，虽然麻烦点，最后的使用效果不错。类似如下错误，根据提示修改即可。(1) expected parenteses around arrow function argument having a body with curly braces arrow-parens箭头函数参数周围的预期括号具有带大括号的主体(2) Empty components are self-closing组件内部空时，不需要自己关闭，如下：12345678910111213141516171819&lt;a href=&#123;link&#125;&gt; &lt;div className=&quot;slider__slide&quot; data-active=&#123;active&#125; style=&#123;slideStyle&#125; onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125; onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125; &#125;&gt;&lt;/div&gt; //此处&lt;/a&gt;&lt;a href=&#123;link&#125;&gt; &lt;div className=&quot;slider__slide&quot; data-active=&#123;active&#125; style=&#123;slideStyle&#125; onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125; onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125; &#125;/&gt;&lt;/a&gt; webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用 webpack与Gulp的区别 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。Webpack的处理速度更快更直接，能打包更多不同类型的文件 这个不详细写了，要再实践总结下，但是这篇文章写得很好，值得学习。https://segmentfault.com/a/1190000006178770?utm_source=tag-newest react UI库Material-UI Material-UI是一个实现了Google’s Material Design设计规范的react组件库。 Ant-design 蚂蚁金服开发的一个基于react的UI组件库 react-weui选择这个ui库本着做微信公众号开发，考虑到她能更好的兼容微信浏览器。 1.安装 npm install weui@1.1.0 react-weui --save 2.使用在App.js中引入模块。 import &apos;weui&apos;; import &apos;react-weui/build/packages/react-weui.css&apos;; 实际使用中，import 相应的组件即可，以首页的tab切换页为例，如下： 1import &#123; Tab, TabBody, TabBar, TabBarItem, Article &#125; from &apos;react-weui&apos;; 详细页面如下 1234567891011121314151617181920212223242526272829303132333435363738&lt;Tab&gt; &lt;TabBody&gt; &lt;Article style=&#123;&#123; display: this.state.tab == 0 ? null : &apos;none&apos; &#125;&#125;&gt; &lt;h1&gt;Page 1&lt;/h1&gt; &lt;section&gt; &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt; &lt;section&gt; &lt;h3&gt;1.1 Title&lt;/h3&gt; &lt;p&gt;1111&lt;/p&gt; &lt;/section&gt; &lt;/section&gt; &lt;/Article&gt; &lt;Article style=&#123;&#123; display: this.state.tab == 1 ? null : &apos;none&apos; &#125;&#125;&gt; &lt;h1&gt;Page 2&lt;/h1&gt; &lt;section&gt; &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt; &lt;section&gt; &lt;h3&gt;2.1 Title&lt;/h3&gt; &lt;p&gt;222&lt;/p&gt; &lt;/section&gt; &lt;/section&gt; &lt;/Article&gt; &lt;/TabBody&gt; &lt;TabBar&gt; &lt;TabBarItem active=&#123;this.state.tab == 0&#125; icon=&#123;&lt;img src=&#123;this.state.urlmain&#125; alt=&quot;购票主页&quot; /&gt;&#125; onClick=&#123;(e) =&gt; this.handleTab(e, 0)&#125; label=&quot;主页&quot; /&gt; &lt;TabBarItem active=&#123;this.state.tab == 1&#125; icon=&#123;&lt;img src=&#123;this.state.urlmine&#125; alt=&quot;个人中心&quot; /&gt;&#125; onClick=&#123;(e) =&gt; this.handleTab(e, 1)&#125; label=&quot;个人中心&quot; /&gt; &lt;/TabBar&gt;&lt;/Tab&gt; 效果如下图 react-weui提供了一系列的组件，可以方便引入和使用，基本可以满足项目中的应用。 集成react-s-alert安装npm install react-s-alert --save 使用在APP中引入样式与库文件。 import Alert from &apos;react-s-alert&apos;; require(&apos;react-s-alert/dist/s-alert-default.css&apos;); require(&apos;react-s-alert/dist/s-alert-css-effects/genie.css&apos;); 具体使用 import Alert from &apos;react-s-alert&apos;; 警告提示12Alert.warning(&apos;请选择添加购票人员&apos;, &#123;position: &apos;top&apos;, offset: 40,onRouteClose: false, timeout: 1500&#125;); 错误提示 Alert.error(json.head.msg, {position: &apos;top&apos;, offset: 40,onRouteClose: false, timeout: 2000, onClose: function () { Utility.toPage(&apos;order&apos;); } }); onClose事件处理提示完之后的操作。 react-confirm-alert安装1npm install react-confirm-alert --save 使用引入相关样式与组件12import &#123; confirmAlert &#125; from &apos;react-confirm-alert&apos;; // Importimport &apos;react-confirm-alert/src/react-confirm-alert.css&apos; // Import css 以退票提示为例，在退票操作之前，询问用户是否确认退票(或者常见的删除前确认提示)。1234567891011121314confirmAlert(&#123; title: &apos;操作提示&apos;, message: &apos;退票将产生[&apos;+fee+&apos;]元手续费，您确认执行退款操作吗?&apos;, buttons: [ &#123; label: &apos;确认&apos;, onClick: () =&gt; this.refund() // 执行退票功能 &#125;, &#123; label: &apos;取消&apos;, onClick: () =&gt; console.log(&apos;取消了操作...&apos;) &#125; ]&#125;) 关于提示的样式可以根据API来设置或者到源码里改改界面颜色。APIhttps://www.npmjs.com/package/react-confirm-alert 问题做完这一个项目，对react以及相关组件了解了个大概，但现在看代码还是很杂很乱，看着闹心。为了赶进度，一些react特性没有好好地应用，还是原始的JavaScript方式。这次基本总结的同时也开始进行了项目重构，希望可以发挥react的优势，优化代码，优化调用以及实现方式等，争取年前完成。 其他 文献资料从零搭建React全家桶框架教程https://github.com/brickspert/react-familyhttps://react.docschina.org/docs/thinking-in-react.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2019%2F01%2F21%2Fredux%2F</url>
    <content type="text"><![CDATA[ReduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。 1.应用中所有的状态都是以一个对象树的形式存储在一个单一的store中；2.当你想要改变应用的中的状态时，你就要dispatch一个action,这也是唯一的改变state的方法；3.通过编写reducer来维护状态，返回新的state,不直接修改原来数据； APIhttps://www.redux.org.cn/ 安装npm install --save redux 使用阮一峰老师关于 Redux 入门教程说法很好： 首先，并非所有的 React 应用程序都需要使用 Redux 的。 如果你不确定是否使用 Rudex ，那么你就是不需要的。如果你遇到了无法解决的难题，那么 Rudex 可能就是你需要的东西。 Redux 的设计思想很简单，就两句话: **1. 整个系统是一个状态机，视图与状态是一一对应的 所有的状态，保存在一个对象里面** State一个state对应着一个view，state改变，view跟着改变。 1234import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; getSlideData &#125; from &apos;actions/slides&apos;;@connect((state) =&gt; (&#123; slideData: state.slideData &#125;), &#123; getSlideData &#125;) connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) 官方API中说 It does not modify the component class passed to it; instead, it returns a new, connected component class for you to use. mapStateToProps(state, ownProps) 方法允许我们将store中的数据作为props绑定到组件中，只要store更新了就会调用mapStateToProps方法mapStateToProps返回的结果必须是object对象，该对象中的值将会更新到组件中。mapDispatchToProps(dispatch, [ownProps]) 第二个参数允许我们将action作为props绑定到组件中，mapDispatchToProps希望你返回包含对应action的object对象 Storestore是redux库中的createStore方法生成的对象，存储的是系统中的公有数据。 12import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;const finalCreateStore = applyMiddleware(...middleware)(createStore); applyMiddleware(科里化函数)主要是对redux的dispacth方法进行封装。 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 用户的行为通过store.dispatch()来出发进行更改state actionstore.dispatch触发action,定义触发的动作。 使用单独的模块或文件来定义 action type 常量并不是必须的，甚至根本不需要定义。对于小应用来说，使用字符串做 action type 更方便些。不过，在大型应用中把它们显式地定义成常量还是利大于弊的。 12345678910export const GET_SLIDES_LOADING = &apos;slides/loading&apos;;export const GET_SLIDES_SUCCESS = &apos;slides/success&apos;;export const GET_SLIDES_FAIL = &apos;slides/fail&apos;;export function getSlideData() &#123; return &#123; types: [GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL], promise: (client) =&gt; client.get(client.API.Slides, &#123; params: &#123; page: 1, rows: 10 &#125; &#125;) &#125;;&#125; 我们应该尽量减少在 action 中传递的数据 Reducer Reducers 指定了应用状态的变化如何响应 actions 并发送到 store. reducer就是一个纯函数，接收旧的 state 和 action，返回新的 state。 1234567891011121314151617181920212223242526import &#123; GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL &#125; from &apos;actions/slides&apos;;const initState = &#123; isLoading: false, slideData: &#123;&#125;, errorMsg: &apos;&apos;,&#125;;export default function reducer(state = initState, action) &#123; switch (action.type) &#123; case GET_SLIDES_FAIL: return &#123; ...state, isLoading: false, slideData: null, errorMsg: &apos;请求错误啦&apos;, &#125;; case GET_SLIDES_LOADING: return &#123; ...state, isLoading: true, slideData: null, errorMsg: &apos;请求中...&apos;, &#125;; case GET_SLIDES_SUCCESS: return &#123; ...state, isLoading: false, slideData: action.result.text, errorMsg: &apos;获取成功&apos;, &#125;; default: return state; &#125;&#125; 本次主要以一个首页轮播图的实现来实例整个流程。 Slider组件通过action把服务器响应(发生)请求送出来，获取轮播信息列表，reducer接收由store传入的请求action和旧的state((previousState, action) =&gt; newState)，将返回结果按自己的格式更新到新的state返回，组件更新UI进行展示。 1234case GET_SLIDES_SUCCESS: return &#123; ...state, isLoading: false, slides: action.result, errorMsg: &apos;获取成功&apos;, &#125;; 组件里获取数据展示 componentDidMount() { this.props.getSlideData().then((data) =&gt; { const nd = JSON.parse(data); if (nd.head.success) { this.setState({ slides: nd.body.rows }); } }, (err) =&gt; { console.log(err); }); setInterval(() =&gt; this.nextSlide(), 2000); }]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本指法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%8C%87%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[义甲佩戴老师说义甲相当于自己的指甲了要与自己的手指贴合，抹、托、打这三个指甲胶带缠绕靠近义甲底部。勾，大拇指缠绕比较特殊，要先把拇指放平，将义甲胶带部分与手指相平，指甲与手指的角度大概是120~130度差不多的位置。 另外，缠绕胶带的时候最好整齐，可能有点强迫症，但也是一个端正的开始。 基本手型右手自然弯曲，虎口处呈C状。弹奏时，指关节动而手不动，需要保持。左手三指并拢，大指与小指延展，手背微弯。无论左手还是右手整体都要是放松的姿势。 基本指法托大指指关节向外弹弦。 抹食指指关节向内弹弦。 勾中指指关节向内弹弦。 打名指指关节向内弹弦。 劈大指指关节向内弹弦。借助大指回拨的力度快速回拨。 大撮大指与中指，大指向外托，中指向里勾，同时弹奏两弦，一个8度。 小撮大指与食指，大指向外托，食指向里抹，同时弹奏两弦，在一个8度之内的都是小撮。 上划音右手先弹弦，左手按该弦。右手先动，左手再跟上，不要喧宾夺主。 下划音左手先按弦，右手弹奏。 回滑音上滑音与下滑音结合。右手弹奏，左手快速按下弹起。 定滑音规定音高的划音，1 12 6（12）之间有定滑音符号，可省略2音，直接跟上6。 颤音右手弹弦后，左手上下起伏按弦。弹奏颤音时，右手先动，左手跟上，注意左手手型。 持续颤音用的较少，比颤音时长长一些。 4和74音，按3音弦半拍，左手轻按弦。7音，按6音弦一拍，左手稍重按弦。 双托大指同时弹两弦。 双抹食指同时弹两弦。 连托大指向外连续弹弦。 连抹食指向内连续弹弦。 上刮奏食指由低音到高音连续弹弦。 下刮奏大指由高音到低音连续弹弦。 花指板前花 不占时值，装饰性的花指。正版花 占一定的时值(变奏) 8度双托是大撮加上连音一同弹奏，加上一个上划音。 其他遥指，大指连续反复托劈。琶音，单手或双手快速连续弹弦。泛音这三个或者其他未列的是尚未学习的，之后再学习过程中重新补充。 问题汇总1.弹奏力度不够，跟老师对比来的时候，明显感觉自己弹出的音太绵软。每个指法在练习的时候都有这个问题，需要多进行复盘，也可能吃多点就好了哈哈。2.一些按弦略有迟疑，在左手下滑音练习时，起手会慢。3.左手在按弦时，习惯性的单指(这是古琴的指法)，要三指并拢，大指与小指延展，手背微弯，整体是个放松的姿势。4.劈以及连托弹奏时，手型不自觉的会变动，同时还有力度问题，需要强化练习恢复过来。5.整体上手指灵活度还是不够，需要每日练习。6.指法符号要与指法对应起来。看到书上的指法符号手指能即时弹奏出来，现在存在看到一个符号要想半天才弹出来的情况。 最后，下次再去上课的时候注意老师弹奏时候的指法，先去模仿，再去练习，最后形成与自己契合的指法。 虽然课后做了笔记，总觉得之后会有丢失，这周重新做下汇总，把没想到的再补充完善下，基本指法比较简略，随着之后的学习再补充完善吧。 得良师春风化雨，有益友万事顺风。]]></content>
      <categories>
        <category>古筝</category>
      </categories>
      <tags>
        <tag>古筝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F01%2F11%2FGit%2F</url>
    <content type="text"><![CDATA[Git将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录1git add . 将缓存区内容添加到本地仓库1git commit -m &apos;注释&apos; 推送到远程服务器1git push 其他添加到暂存区时，出现很多untrack1git clean -f 之后，重新进行了添加，有个问题是将一些不需要的模块也上传了上去，于是做了清理以及重新添加提交等操作。 1git add * 查看当前仓库中文件的状态。 1git status 如果没有问题，进行提交到本地仓库，最后推送到远程服务器。 查看当前分支1git branch 更新代码到本地1git pull 此次将博客维护在了github上方便多台电脑操作，node_modules模块实在没必要上传维护，创建.gitignore文件,将不需要的文件夹配置在里面，被ignore的文件肯定不会被标上untracked，上面的问题就是显示红字untracked。在其他电脑上使用npm重新安装就可以，每次在更新博客时，要重新pull。 .gitignore文件配置1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 所有事情到最后都会是好事，如果还不是，那她还没到最后——约翰*列侬]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件通信方式总结]]></title>
    <url>%2F2019%2F01%2F09%2FReact%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[React组件通信方式父组件向子组件通信 父组件更新组件状态，通过props传递给子组件，子组件得到后进行更新。 Timer 是倒计时子组件，集成在了OrderPay父组件里，父组件向子组件传订单数据参数order对象。如下代码： &lt;Timer order={order} /&gt; //倒计时组件 在子组件里直接通过props获取父组件传递过来的参数，如下： let order = this.props.order;//订单详情 子组件向父组件通信 子组件更新组件状态，通过回调函数的方式传递给父组件。 子组件调用父组件通过props传给它的函数更新父组件state，进而完成子组件向父组件的通讯。 先看父组件1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;//导入子组件import Child from &apos;./child.js&apos;; class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; msg: &apos;父组件初始msg&apos; &#125; &#125; //父组件回调函数，更新state，进而更新父组件。 callback=(msg)=&gt;&#123; // setState方法,修改msg参数,值是由子组件传过来。 this.setState(&#123;msg&#125;); &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;子组件传值实验: &#123;this.state.msg&#125;&lt;/p&gt; &lt;Child callback=&#123;this.callback&#125; &gt;&lt;/Child&gt; &lt;/div&gt; ); &#125;&#125;export default App; 再看子组件 1234567891011121314151617181920212223import React from &quot;react&quot;;class Child extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; msg: &apos;子组件msg传值&apos; &#125; &#125; //通过props调用回调函数传值 trans=()=&gt;&#123; this.props.callback(this.state.msg); &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.trans&#125;&gt;激发trans事件，传值给父组件&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Child; 效果 跨级组件间通信 举个例子react-redux的，也是通过Context提供一个全局态的store。还有用户信息的使用，也可以通过context中传递数据。 通过props或state传值比较麻烦，context提供了一种组件之间共享数据的方式，可以避免数据在组件树上逐层传递，也就是用Context来实现跨层级的组件数据传递。 这篇文章写得非常好，看完就能理解context，上手实验更能理解透彻，毕竟最后都要应用起来。https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。 生产者123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;class App extends Component &#123; constructor(props)&#123; super(props); &#125; //生产者 //Context生产者，通过静态属性childContextTypes声明提供给子组件的Context对象的属性， static childContextTypes = &#123; propA: PropTypes.string &#125; //实例getChildContext方法，返回Context对象 getChildContext () &#123; return &#123; propA: &apos;propA&apos; &#125; &#125; render() &#123; return &lt;BppComponent /&gt; &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return &lt;CppComponent /&gt; &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 //子组件需要通过一个静态属性contextTypes声明后，才可以访问父组件Context对象的属性 static contextTypes = &#123; propA: PropTypes.string &#125; render () &#123; return( &lt;div&gt; &lt;p&gt;从生产者传递过来的属性A：&#123;this.context.propA&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default CppComponent; react升级后，Context的新API做了变更。 1234type Context&lt;T&gt; = &#123; Provider: Provider&lt;T&gt;, Consumer: Consumer&lt;T&gt;,&#125;; 消费者 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;const CommContext = React.createContext(&#123; a: &apos;aaaaa&apos;, b: &apos;bbbbb&apos;&#125;);class App extends Component &#123; //父组件 constructor(props)&#123; super(props); &#125; render() &#123; return( &lt;CommContext.Provider&gt; &lt;BppComponent /&gt; &lt;/CommContext.Provider&gt; ) &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return ( &lt;CppComponent&gt;context跨层级传参实验&lt;/CppComponent&gt; ); &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import PropTypes from &apos;prop-types&apos;/** * 通过静态方法React.createContext()创建一个Context对象， * 这个Context对象包含两个组件，&lt;Provider /&gt;和&lt;Consumer /&gt; */const CommContext = React.createContext(&#123; a: &apos;newaaaaa&apos;, b: &apos;newbbbbb&apos;&#125;);/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 render () &#123; return( &lt;CommContext.Consumer&gt; &#123; context =&gt; ( &lt;div&gt; &#123;this.props.children&#125; &lt;br/&gt; 参数a: &#123;context.a&#125; &lt;br/&gt; 参数b: &#123;context.b&#125; &lt;/div&gt; )&#125; &lt;/CommContext.Consumer&gt; ) &#125;&#125;export default CppComponent; 效果 其他使用方式构造方法： constructor(props, context) 生命周期： componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componetWillUpdate(nextProps, nextState, nextContext) 注入式的组件，类似背景、语言这种控制全局的变量，可使用context。 非嵌套组件间通信 非嵌套组件: 就是没有任何包含关系的组件,包括兄弟组件以及不再同一个父级的非兄弟组件。使用事件订阅，即一个发布者，一个或多个订阅者。 安装eventnpm install event -save 新建Evt.js，导入eventsimport {EventEmitter} from &apos;events&apos;; export default new EventEmitter(); 发布者通过emit事件触发方法，发布订阅消息给订阅者。发布者123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import Custom1 from &apos;./Custom1.js&apos;;import Custom2 from &apos;./Custom2.js&apos;;import emitter from &apos;./Evt.js&apos;;class App extends Component &#123; constructor()&#123; super(); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; //emit事件触发方法,过事件名称找对应的事件处理函数callCustom，将事件处理函数作为参数传入 emitter.emit(&apos;callCustom&apos;, &apos;Hello 我来发消息了&apos;); &#125; render() &#123; return( &lt;div&gt; &lt;br/&gt; &lt;button onClick = &#123;this.handleClick&#125;&gt;点击发布事件&lt;/button&gt; &lt;Custom1 /&gt; &lt;Custom2 /&gt; &lt;/div&gt; ) &#125;&#125;export default App; 订阅者Custom1 和 Custom2通过emitter.addListener(事件名称,函数名)方法，进行事件监听(订阅)。通过emitter.removeListener(事件名称,函数名)方法 ，进行事件销毁(取消订阅) 订阅者1 12345678910111213141516171819202122232425262728293031323334353637import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom1 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1收到消息--&apos;+msg &#125;); &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1即将销毁此消息--&apos;+ msg &#125;); &#125;) &#125; //订阅者1消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.state.msg&#125; &lt;/p&gt;) &#125;&#125;export default Custom1; 订阅者2 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom2 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2收到消息--&apos;+msg &#125;) &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2即将销毁此消息--&apos;+ msg &#125;) &#125;) &#125; //订阅者2消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;blue&apos;&#125;&#125;&gt;&#123;this.state.msg&#125;&lt;/p&gt;) &#125;&#125;export default Custom2; 运行效果如下：发布者发布消息前订阅者接收消息后 文献资料非嵌套组件通信详解https://blog.csdn.net/bbgdebb/article/details/79006277node.js源码解析-eventshttps://blog.csdn.net/leoleocs/article/details/50162065]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口问题以及解决方案汇总]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[接口问题以及解决方案汇总需求描述 省内接口转为全国统一接口，作为接口中转，主要是承上启下的作用。保持前端请求以及参数不变的情况下，业务逻辑集中处理；提供给第三方或者四方?!调用；当接口变更时只更改当前接口项目即可。 问题1java.net.URISyntaxException //Http Get请求报出此次错误。 问题原因： 第三方接口需要将参数部分进行编码后提交。 原接口进行了编码传到中转接口这里仍然需要获取并重新编码传给第三方。 解决办法： 重新进行编码URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;) 问题2关于接口请求参数JSON格式的重新封装问题。 问题原因： 请求参数param是json格式的，接收过来的参数不能直接toJSONString，编码后传给第三方 解决办法：1234if (map.containsKey(&quot;param&quot;)) &#123; JSONObject param = JSONObject.parseObject((String)map.get(&quot;param&quot;)); url = url + &quot;&amp;param=&quot; + URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;);&#125; 针对接口调用做简单的记录，方便今后查看。其实最好的框架是适合项目本身的，与高级或所谓低端无关，越是简单的反而更能解决问题，提升效率。 是非入耳君须忍，半作痴呆半作聋。]]></content>
      <categories>
        <category>接口</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题与配置优化]]></title>
    <url>%2F2019%2F01%2F03%2FHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[next主题配置https://hexo.io/themes/ 主题选择，本文是next主题安装配置以及优化。 安装与配置安装在博客根目录，打开git bash, git clone https://github.com/theme-next/hexo-theme-next themes / next 安装完毕后在站点目录下themes文件夹生成next主题文件夹。 站点开启主题在站点根目录设置主题：next next主题中文设置站点配置文件_config.yml language: zh-Hans Scheme 外观设置这里选择了双栏Pisces Muse黑白主调，大量留白。 Mist是Muse的紧凑版本，整洁有序的单栏外观 Gemini左侧网站信息及目录，块+片段结构布局 新增菜单设置第一步： hexo new page &apos;name&apos; # name分别为tags、categories、about 具体生成如下： hexo new page &apos;tags&apos; #创建tags标签子目录 hexo new page &apos;categories&apos; #创建categories分类子目录 hexo new page &apos;about&apos; #创建about关于子目录 第二步： 修改这tags和categories文件夹中的index.md，设置如下： 主题优化公益404将公益404一份在网页丢失时候。另外还放在了关于里面。 在网页丢失时候： 第一步：创建404页面 hexo new page 404 ; 第二步：在站点source文件夹下创建404.html，将如下代码粘贴进去，保存！ 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;]\&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网易云音乐注册一个网易账号，生成一个自己的一个歌单，加入自己喜欢的音乐。 在网易云插件里，嵌入iframe(可以根据自己设定调整，然后复制代码) hexo配置，在next主题下/layout/_macro/sidebar.swig文件里添加复制的代码即可。 配置显示在左侧栏中 点击桃心第一步： 在 /themes/next/source/js/src 文件夹下创建 clklove.js 将如下代码粘贴进去，保存！ 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 第二步： 在主题文件夹下 \themes\next\layout\_layout.swig文件末尾，引入创建的js文件，如下： 动态背景第一步：引入文件 123&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 第二步： 在next主题配置文件_config.yml设置 canvas_nest: true 搜索第一步：安装插件 npm install hexo-generator-searchdb --save 第二步：站点配置文件修改 12345search: path: search.xml field: post format: html limit: 10000 第三步：主题配置文件修改 12345# Local searchlocal_search: enable: true top_n_per_article: 1 unescape: false RSS第一步：安装插件 npm install hexo-generator-feed 第二步：站点配置 _config.yml配置文件添加以下代码： 1234567plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 第三步：主题配置 在themes目录下的_config.yml配置如下 rss: /atom.xml 进学致和，行方思远。——字严]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础]]></title>
    <url>%2F2018%2F12%2F29%2F%E4%BD%BF%E7%94%A8hexo%2BGitHub%2B%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[关于hexohttps://hexo.io/zh-cn/docs/ hexo官方文档连接地址 安装node和git 请自行从网上查找适合自己系统和版本进行安装。 node安装https://nodejs.org/zh-cn/ 自行配置Node.js环境 git安装git 下载 https://git-scm.com/download Hexo安装与启动部署npm install -g hexo-cli //hexo插件安装 hexo init blob //初始化hexo文件夹blob cd blob npm install hexo generate //可简写为hexo g hexo sever //可简写为hexo s 访问 http://localhost:4000 Hello World 上传GitHub安装github插件npm install hexo-deployer-git --save //安装插件 github注册以及配置(1) 没有GitHub的访问以下网站注册一个账户 https://github.com (2) 建立资源库，例如blob (3) 在hexo中配置该仓库地址 本地站点github相关配置找到hexo安装目录blob文件夹，在站点配置文件_config.yml里修改如下配置： deploy: type: git repository: git@github.com:你的Github账户/仓库.git branch: master 部署静态文件到github通过git bash部署到github上 hexo deploy //可简写为 hexo d 域名关联gitpage(1) 阿里云域名配置 在阿里云域名模块解析域名配置 将记录类型设置为CNAME； 记录值修改为 yourname.github.io 在hexo安装目录中找到source文件夹 新建CNAME文件，没有后缀。 将你的域名放在新建的CNAME文件中。 (2) GitHub Pages配置 在blob资源仓库中Setting里， 下拉找到GitHub Pages部分 配置 Custom domain，将你的域名填写进去，点击save。 其他//清除缓存 hexo clean //生成静态网页 hexo g //部署到git hexo d //本地服务启动 hexo s 比较简略，大体流程就是这些，个人觉得在自己动手查找过程会有更多的收获。 纸上得来终觉浅，觉知此事要躬行。——陆游]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
