<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spingboot ActiveMQ订阅发布模式]]></title>
    <url>%2F2019%2F02%2F27%2FSpingboot%20ActiveMQ%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用场景：人员通过人脸识别以及证件比对，车辆车牌号识别上传事件；消费者通过事件订阅获取人证比对事件类型，车辆通过车牌号识别车辆驶入和驶离事件类型，将监听到的消息事件同步保存到本地，便于图形化展示。 ActiveMQActiveMQ官网下载地址：http://activemq.apache.org/download.html安装、启动之后，http://127.0.0.1:8161 admin admin 的默认账户登陆到ActiveMQ主界面中，topics和queues消息订阅监控查询可以通过发布以及订阅消息来测试配置等。 Topic和QueueTopic：发布/订阅，可多个消费者同时订阅Queue：点对点，可以有多个消费者但是消息不能重复被消费。通过先进先出顺序存储，消息被消费了才被删除。本次使用Topic一对多的消息接收策略。 配置pom.xml中添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 创建ActiveMQ启动配置类项目中需要的是多个topic消息队列的监听 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import javax.jms.Topic;import org.apache.activemq.ActiveMQConnectionFactory;import org.apache.activemq.command.ActiveMQTopic;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.annotation.EnableJms;import org.springframework.jms.config.DefaultJmsListenerContainerFactory;import cc.army.hkapi.mq.MQClientUtil; @Configuration @EnableJmspublic class ActiveMQ4Config &#123; @Bean public Topic topic() throws Exception&#123; // 获取第一个acs String DES = MQClientUtil.getMQInfoAcs().getString(&quot;destination&quot;); return new ActiveMQTopic(DES); &#125; @Bean public Topic topicpms() throws Exception&#123; // 获取第二个pms String DES = MQClientUtil.getMQInfoPms().getString(&quot;destination&quot;); return new ActiveMQTopic(DES); &#125; @Bean(name=&quot;activeMQConnectionFactory&quot;) public ActiveMQConnectionFactory activeMQConnectionFactory() throws Exception&#123; String BROKER_URL = MQClientUtil.getMQInfoAcs().getString(&quot;mqURL&quot;); ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(&quot;failover:(tcp://&quot;+BROKER_URL+&quot;)&quot;); return activeMQConnectionFactory; &#125; //定义一个消息监听器连接工厂，这里定义的是topic模式的监听器连接工厂 @Bean(name = &quot;jmsTopicListener&quot;) public DefaultJmsListenerContainerFactory jmsTopicListenerContainerFactory(@Qualifier(&quot;activeMQConnectionFactory&quot;)ActiveMQConnectionFactory activeMQConnectionFactory) &#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(activeMQConnectionFactory); factory.setConcurrency(&quot;2-10&quot;);//设置连接数 factory.setPubSubDomain(true); //topic return factory; &#125;&#125; 实现消息消费者@JmsListener注解标识监听哪一个消息队列。 人员进出门记录监听以及同步 12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.jms.BytesMessage;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component;......@Componentpublic class Consumer &#123; private final static Logger logger = LoggerFactory.getLogger(Consumer.class); @JmsListener(destination = &quot;openapi.acs.topic&quot;, containerFactory = &quot;jmsTopicListener&quot;) public void receiveTopic(Message msg, Session session) throws JMSException &#123; try &#123; // cms里发送的消息为BytesMessage，此处不做判断亦可 if (msg instanceof BytesMessage) &#123; BytesMessage bytesMessage = (BytesMessage)msg; long length = bytesMessage.getBodyLength(); byte[] bt = new byte[(int)length]; // 将BytesMessage转换为byte类型 bytesMessage.readBytes(bt); // 壳文件字段，EventDis类为event_dis.proto文件解析而来，CommEventLog类为事件壳文件类 EventDis.CommEventLog parseFrom = EventDis.CommEventLog.parseFrom(bt); // 扩展字段，此字段为设备上报事件内容，部分事件需要使用pb文件再次解析 ByteString extInfo = parseFrom.getExtInfo(); // 输出扩展字段 logger.info(&quot;extInfo &quot;+extInfo.toStringUtf8()); AcsEvent.AccessEventLog aa = AcsEvent.AccessEventLog.parseFrom(extInfo); if(aa.getEventCode()==83912960) &#123;//人证比对通过 logger.info(&quot;83912960 订阅事件 [人证比对]通过&quot;); syncRecord(aa);//同步记录 &#125; &#125; &#125; catch (Exception e) &#123; logger.error(&quot;监听错误信息为：&quot;+e.getMessage()); &#125; &#125; 车辆进出门记录监听以及同步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.jms.BytesMessage;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component;......@Componentpublic class ConsumerPms &#123; private final static Logger logger = LoggerFactory.getLogger(ConsumerPms.class); @JmsListener(destination = &quot;openapi.pms.topic&quot;, containerFactory = &quot;jmsTopicListener&quot;) public void receiveTopicPms(Message msg, Session session) throws JMSException &#123; try &#123; // cms里发送的消息为BytesMessage，此处不做判断亦可 if (msg instanceof BytesMessage) &#123; BytesMessage bytesMessage = (BytesMessage)msg; long length = bytesMessage.getBodyLength(); byte[] bt = new byte[(int)length]; // 将BytesMessage转换为byte类型 bytesMessage.readBytes(bt); // 壳文件字段，EventDis类为event_dis.proto文件解析而来，CommEventLog类为事件壳文件类 EventDis.CommEventLog parseFrom = EventDis.CommEventLog.parseFrom(bt); // 输出壳文件字段 // 扩展字段，此字段为设备上报事件内容，部分事件需要使用pb文件再次解析 ByteString extInfo = parseFrom.getExtInfo(); // 输出扩展字段 logger.info(&quot;extInfo &quot;+extInfo.toStringUtf8()); PmsEvent.MsgPmsEvent aa = PmsEvent.MsgPmsEvent.parseFrom(extInfo); if(parseFrom.getEventType()==Constant.COMMON_CAR_ENTER) &#123;//车辆停入 syncCarRecord(aa.getPmsEvent(), 1); &#125; if(parseFrom.getEventType()==Constant.COMMON_CAR_OUT) &#123;//车辆驶离 syncCarRecord(aa.getPmsEvent(), 2); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(&quot;车辆进出监听错误信息为：&quot;+e.getMessage()); &#125; &#125; 本次使用中事件订阅会有消息重复接收的问题，同步记录时可以通过数据库索引等方式做预处理。 扩展学习 Kafka下的生产消费者模式与订阅发布模式]]></content>
      <categories>
        <category>Spingboot</category>
      </categories>
      <tags>
        <tag>Spingboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot接口版本管理]]></title>
    <url>%2F2019%2F02%2F18%2FSpringboot%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统上线后，随着需求的变化，接口在调用过程中也会发生变化，为了兼容新老用户的使用方便，需要提供不同需求调用不同接口版本来实现。通过更改接口地址方式实现。 版本控制自定义ApiVersion注解，以实现随机获取路径的版本号。12345678910import java.lang.annotation.*;//版本控制@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface ApiVersion &#123; int value();&#125; ApiVersionCondition自定义实现了RequestCondition接口，通过正则表达式获得需要匹配的版本号。12345678910111213141516171819202122232425262728293031323334353637383940414243import org.springframework.web.servlet.mvc.condition.RequestCondition;import javax.servlet.http.HttpServletRequest;import java.util.regex.Matcher;import java.util.regex.Pattern;public class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; &#123; // 路径中版本的前缀， 这里用 /v[1-9]/的形式 private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\d+)/&quot;); private int apiVersion; public ApiVersionCondition(int apiVersion) &#123; this.apiVersion = apiVersion; &#125; @Override public ApiVersionCondition combine(ApiVersionCondition other) &#123; // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义 return new ApiVersionCondition(other.getApiVersion()); &#125; @Override public ApiVersionCondition getMatchingCondition(HttpServletRequest request) &#123; Matcher m = VERSION_PREFIX_PATTERN.matcher(request.getRequestURI()); if (m.find()) &#123; Integer version = Integer.valueOf(m.group(1)); if (version &gt;= this.apiVersion) &#123; return this; &#125; &#125; return null; &#125; @Override public int compareTo(ApiVersionCondition other, HttpServletRequest request) &#123; // 优先匹配最新的版本号 return other.getApiVersion() - this.apiVersion; &#125; public int getApiVersion() &#123; return apiVersion; &#125;&#125; 自定义CustomRequestMappingHandlerMapping自定义CustomRequestMappingHandlerMapping ，继承RequestMappingHandlerMapping，获得注解标注的接口路径，然后返回自定义的实现类。12345678910111213141516171819202122232425import org.springframework.core.annotation.AnnotationUtils;import org.springframework.web.servlet.mvc.condition.RequestCondition;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import com.bk.framework.config.ApiVersion;import java.lang.reflect.Method;public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping &#123; @Override protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); return createCondition(apiVersion); &#125; @Override protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class); return createCondition(apiVersion); &#125; private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) &#123; return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value()); &#125;&#125; WebMvcRegistrationsWebMvcRegistrations接口下提供了WebMvcRegistrationsAdapter转换器，它可以指定自定义的RequestMappingHandlerMapping。 1234567891011import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.autoconfigure.web.servlet.WebMvcRegistrations;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;@SpringBootConfigurationpublic class WebMvcRegistrationsConfig implements WebMvcRegistrations &#123; @Override public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123; return new CustomRequestMappingHandlerMapping(); &#125;&#125; 版本测试类HelloController12345678910111213141516171819202122232425import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.bk.framework.config.ApiVersion;/** * 接口版本测试类 */@RestController@RequestMapping(&quot;/api&quot;)public class HelloController &#123; @ApiVersion(1) @GetMapping(&quot;/&#123;version&#125;/version&quot;) public String test1()&#123; return &quot;Hello World! version 1&quot;; &#125; @ApiVersion(2) @GetMapping(&quot;/&#123;version&#125;/version&quot;) public String test2()&#123; return &quot;Hello World! version 2&quot;; &#125;&#125; 运行 http://localhost:8086/bk/api/v1/version 输出 Hello World! version 1运行 http://localhost:8086/bk/api/v2/version 输出 Hello World! version 2 参考 https://blog.csdn.net/u010782227/article/details/74905404]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React前端开发总结]]></title>
    <url>%2F2019%2F01%2F21%2FReact%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第一次使用react，还是习惯性的去找了合适的移动开发框架，直接在此基础上迭代开发。优点是能快速及时上手一个项目，边开发应用边学习，能做出一个可以用，可以看的东西。缺点是不能系统的学习，她的特性不能系统全面地掌握以及与之相关的技术底层能用但是原理模糊。整个项目虽然功能实现，但是是在一知半解状态做出来，边开发边解决问题，边重构迭代，react的优势并没有完全发挥出来。希望系统学习之后能进行一次整体重构。 开发工具选择开发工具Sublime Text 3使用这个就是因为以前用过，上手快，而且她快速，稳定，但是需要购买证书。 Vscode速度较快，对超大文件读写速度飞快。 Atom速度一般，更新快，占用资源较大。 调试工具 在 Chrome 上可以安装 React 开发者工具插件，这样就能在浏览器的开发控制台里看到 React 渲染出来的组件树，调试查看挺方便。 微信web开发者工具。鉴于开发微信公众号应用，开发使用微信web开发者工具，可以提供公众号网页和小程序的开发，微信API里有提供下载链接。https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140React全家桶 react + redux + react-router + less/sass + ES6 + webpackreact全家桶，react使用的标配，一个个做简单的说明。 构建开发环境demo使用create-react-app构建React开发环境，node以及npm已配置。npm慢可以使用淘宝定制的cnpm，设置如下： npm install -g cnpm --registry=https://registry.npm.taobao.org npm config set registry https://registry.npm.taobao.org create-react-app demo安装 create-react-app my-app cnpm install -g create-react-app cd my-app/ npm start 启动之后，http://localhost:3000/接下来可以在此基础上，学习或者实验react相关… react采用声明式，高效而且灵活的用来构建用户界面的框架。 官方文档 https://react.docschina.org 虚拟domreact-dom提供操作DOM的扩展库。 JSX通过babel解析JSX语法代码转为纯JS语法代码的库。 组件 面向组件编程的(组件化编码开发)，最后得到标签代码，同时组件之间可以进行通信，数据传递也非常灵活。关于组件通信方式，下面单独做了实验与总结。 组件通讯方式 组件通信方式汇总 其他组件上加上prop-types进行验证 optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol redux虽然使用的脚手架中整合了redux，但是在使用中，为了赶进度没有使用，重构的时候也把这部分也加上了。 只有遇到 React 实在解决不了的问题，你才需要 Redux 。 redux简单做了个总结。Redux总结 react-router 用于构建路由，主要有Router，IndexRoute，Route，Link，IndexLink这几个组件，以及hashHistory，browserHistory。 安装npm install --save react-router 使用项目部署的时候，原配置createHashHistory出现一片白问题，后来更换了createBrowserHistory，重新部署后可访问。区别browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；hashHistory 是通过改变地址后面的 hash来改变浏览器的历史记录。 1import createHistory from &apos;history/createBrowserHistory&apos; 从 React Router 中导入 import { BrowserRouter as Router, Route } from &apos;react-router-dom&apos;; react-router嵌套路由 Router包裹Route，当url变化的时候，Router将会匹配到指定的路由，然后渲染路由绑定的组件。Route用来显式地把路由映射到应用的组件结构上。 用path指定url，用component指定路由命中url后需要渲染的那个组件。 如下： &lt;Router basename={AppCfg.app.BaseName}&gt; &lt;App&gt; &lt;Route exact path=&quot;/&quot; component={CreateComponent(Default)} /&gt; &lt;Route path=&quot;/home&quot; component={CreateComponent(Home)} /&gt; &lt;Route path=&quot;/userinfo&quot; component={CreateComponent(UserInfo)} /&gt; &lt;/App&gt; &lt;/Router&gt; 通过Provider将redux绑定到react，同时用Provider包裹路由，路由控制器就可以访问store。 &lt;AppContainer warnings={false}&gt; &lt;Provider store={ApiClientStore} key=&quot;provider&quot;&gt; &lt;Router history={history}&gt; {RootElement} &lt;/Router&gt; &lt;/Provider&gt; &lt;/AppContainer&gt; Switch Switch的特点是从上往下读,只要有一个匹配成功,就不会往下读(Switch是由包容性变成排他性的一个重要组件) 在具体页面跳转中使用switch 1234567import &#123; Switch &#125; from &apos;react-router-dom&apos;;const &#123; location &#125; = route || &#123;&#125;;const &#123; key &#125; = location || &#123;&#125;;&lt;Switch key=&#123;key&#125; location=&#123;location&#125;&gt; &#123;this.props.children&#125;&lt;/Switch&gt; 其他 React Router 提供一个 routerWillLeave生命周期钩子，这使得 React 组件可以拦截正在发生的跳转，或在离开 route 前提示用户。routerWillLeave 返回值有以下两种：return false 取消此次跳转return 返回提示信息，在离开 route 前提示用户进行确认。 12345678910111213141516import &#123; Lifecycle &#125; from &apos;react-router&apos;const Home = React.createClass(&#123; // 假设 Home 是一个 route 组件，它可能会使用 // Lifecycle mixin 去获得一个 routerWillLeave 方法。 mixins: [ Lifecycle ], routerWillLeave(nextLocation) &#123; if (!this.state.isSaved) return &apos;Your work is not saved! Are you sure you want to leave?&apos; &#125;, // ...&#125;) LinksLink在内部做了一个操作,把标签变成了a标签。 &lt;Link to=&quot;user&quot; params={{userId: user.id}}&gt;touser&lt;/Link&gt; Redirect组件(重定向)from(使用绝对路径)exact(精准匹配)to(跳转路径) less/sass本次开发中使用sass，由于使用了react-weui样式使用较少了。SASS是一种CSS的开发工具，使CSS的开发，变得简单和可维护。可以查看阮一峰老师关于此教程。http://www.ruanyifeng.com/blog/2012/06/sass.html ES6声明方式var 、function 、let 、const 、import、 class。 ES6中明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量就会报错。 箭头函数相当于匿名函数，使用“箭头”（=&gt;）定义函数。无参箭头函数 setInterval(() =&gt; this.nextSlide(), 2000); 一个参数箭头函数 x =&gt; {console.log(x*x)} 多个参数箭头函数 参数需要用括号()括起来 &apos;use strict&apos; var arr = [10, 20, 1, 2]; arr.sort((x, y) =&gt; { if(x-y&gt;0){ return 1; }else{ return -1; } }); console.log(arr); // [1, 2, 10, 20] 可变参数…rest1234567(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 其他 this,箭头函数内部的this是词法作用域，由上下文确定。 函数体返回表达式的需要使用括号，例 x =&gt; ({ foo: x }) Es6箭头函数说明挺全也很简明https://www.cnblogs.com/snandy/p/4403111.html ESLint ES6 ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 重构时候原来的代码都有问题，前后空格、无效的代码以及分号等等各种问题。一开始使用eslint确实会影响进度，但是对于规范代码以及语法有很好的引导，虽然麻烦点，最后的使用效果不错。类似如下错误，根据提示修改即可。(1) expected parenteses around arrow function argument having a body with curly braces arrow-parens箭头函数参数周围的预期括号具有带大括号的主体(2) Empty components are self-closing组件内部空时，不需要自己关闭，如下：12345678910111213141516171819&lt;a href=&#123;link&#125;&gt; &lt;div className=&quot;slider__slide&quot; //此处 data-active=&#123;active&#125; style=&#123;slideStyle&#125; onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125; onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125; &#125;&gt;&lt;/div&gt; //此处&lt;/a&gt;&lt;a href=&#123;link&#125;&gt; &lt;div className=&quot;slider__slide&quot; //换行 data-active=&#123;active&#125; style=&#123;slideStyle&#125; onTouchStart=&#123;(ev) =&gt; &#123; this.clickCarousel(carouselId, ev); &#125;&#125; onTouchEnd=&#123;(ev) =&gt; &#123; this.touchEnd(ev); &#125; &#125;/&gt; //空的div去除&lt;/a&gt; webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用 webpack与Gulp的区别 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。Webpack的处理速度更快更直接，能打包更多不同类型的文件 这个不详细写了，要再实践总结下，但是这篇文章写得很好，值得学习。https://segmentfault.com/a/1190000006178770?utm_source=tag-newest react UI库UI库的选择上，找了好几个，鉴于微信公众号网页的兼容性，最后选择了react-weui。 Material-UI Material-UI是一个实现了Google’s Material Design设计规范的react组件库。 Ant-design 蚂蚁金服开发的一个基于react的UI组件库 react-weuiAPIhttps://weui.github.io/react-weui/docs 1.安装 npm install weui@1.1.0 react-weui --save 2.使用在App.js中引入模块。 import &apos;weui&apos;; import &apos;react-weui/build/packages/react-weui.css&apos;; 实际使用中，import 相应的组件即可，以首页的tab切换页为例，如下： 1import &#123; Tab, TabBody, TabBar, TabBarItem, Article &#125; from &apos;react-weui&apos;; 详细页面如下 1234567891011121314151617181920212223242526272829303132333435363738&lt;Tab&gt; &lt;TabBody&gt; &lt;Article style=&#123;&#123; display: this.state.tab == 0 ? null : &apos;none&apos; &#125;&#125;&gt; &lt;h1&gt;Page 1&lt;/h1&gt; &lt;section&gt; &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt; &lt;section&gt; &lt;h3&gt;1.1 Title&lt;/h3&gt; &lt;p&gt;1111&lt;/p&gt; &lt;/section&gt; &lt;/section&gt; &lt;/Article&gt; &lt;Article style=&#123;&#123; display: this.state.tab == 1 ? null : &apos;none&apos; &#125;&#125;&gt; &lt;h1&gt;Page 2&lt;/h1&gt; &lt;section&gt; &lt;h2 className=&quot;title&quot;&gt;Heading&lt;/h2&gt; &lt;section&gt; &lt;h3&gt;2.1 Title&lt;/h3&gt; &lt;p&gt;222&lt;/p&gt; &lt;/section&gt; &lt;/section&gt; &lt;/Article&gt; &lt;/TabBody&gt; &lt;TabBar&gt; &lt;TabBarItem active=&#123;this.state.tab == 0&#125; icon=&#123;&lt;img src=&#123;this.state.urlmain&#125; alt=&quot;购票主页&quot; /&gt;&#125; onClick=&#123;(e) =&gt; this.handleTab(e, 0)&#125; label=&quot;主页&quot; /&gt; &lt;TabBarItem active=&#123;this.state.tab == 1&#125; icon=&#123;&lt;img src=&#123;this.state.urlmine&#125; alt=&quot;个人中心&quot; /&gt;&#125; onClick=&#123;(e) =&gt; this.handleTab(e, 1)&#125; label=&quot;个人中心&quot; /&gt; &lt;/TabBar&gt;&lt;/Tab&gt; 效果如下图 react-weui提供了一系列的组件，可以方便引入和使用，基本可以满足项目中的应用。 支付宝支付其实一开始对微信里使用支付宝支付这个感觉有点喧宾夺主了。但是微信里还真的可以这么干，也挺有意思的。总之，用户需求至上。不过支付宝给出的解决方案里真正使用有点另起炉灶的意思。 1.需要引入相关的js文件作为支撑ap.js。 1(function()&#123;var b=&#123;&#125;;var a=&#123;&#125;;a.PADCHAR=&quot;=&quot;;a.ALPHA=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;a.makeDOMException=function()&#123;var f,d;try&#123;return new DOMException(DOMException.INVALID_CHARACTER_ERR)&#125;catch(d)&#123;var c=new Error(&quot;DOM Exception 5&quot;);c.code=c.number=5;c.name=c.description=&quot;INVALID_CHARACTER_ERR&quot;;c.toString=function()&#123;return&quot;Error: &quot;+c.name+&quot;: &quot;+c.message&#125;;return c&#125;&#125;;a.getbyte64=function(e,d)&#123;var c=a.ALPHA.indexOf(e.charAt(d));if(c===-1)&#123;throw a.makeDOMException()&#125;return c&#125;;a.decode=function(f)&#123;f=&quot;&quot;+f;var j=a.getbyte64;var h,e,g;var d=f.length;if(d===0)&#123;return f&#125;if(d%4!==0)&#123;throw a.makeDOMException()&#125;h=0;if(f.charAt(d-1)===a.PADCHAR)&#123;h=1;if(f.charAt(d-2)===a.PADCHAR)&#123;h=2&#125;d-=4&#125;var c=[];for(e=0;e&lt;d;e+=4)&#123;g=(j(f,e)&lt;&lt;18)|(j(f,e+1)&lt;&lt;12)|(j(f,e+2)&lt;&lt;6)|j(f,e+3);c.push(String.fromCharCode(g&gt;&gt;16,(g&gt;&gt;8)&amp;255,g&amp;255))&#125;switch(h)&#123;case 1:g=(j(f,e)&lt;&lt;18)|(j(f,e+1)&lt;&lt;12)|(j(f,e+2)&lt;&lt;6);c.push(String.fromCharCode(g&gt;&gt;16,(g&gt;&gt;8)&amp;255));break;case 2:g=(j(f,e)&lt;&lt;18)|(j(f,e+1)&lt;&lt;12);c.push(String.fromCharCode(g&gt;&gt;16));break&#125;return c.join(&quot;&quot;)&#125;;a.getbyte=function(e,d)&#123;var c=e.charCodeAt(d);if(c&gt;255)&#123;throw a.makeDOMException()&#125;return c&#125;;a.encode=function(f)&#123;if(arguments.length!==1)&#123;throw new SyntaxError(&quot;Not enough arguments&quot;)&#125;var g=a.PADCHAR;var h=a.ALPHA;var k=a.getbyte;var e,j;var c=[];f=&quot;&quot;+f;var d=f.length-f.length%3;if(f.length===0)&#123;return f&#125;for(e=0;e&lt;d;e+=3)&#123;j=(k(f,e)&lt;&lt;16)|(k(f,e+1)&lt;&lt;8)|k(f,e+2);c.push(h.charAt(j&gt;&gt;18));c.push(h.charAt((j&gt;&gt;12)&amp;63));c.push(h.charAt((j&gt;&gt;6)&amp;63));c.push(h.charAt(j&amp;63))&#125;switch(f.length-d)&#123;case 1:j=k(f,e)&lt;&lt;16;c.push(h.charAt(j&gt;&gt;18)+h.charAt((j&gt;&gt;12)&amp;63)+g+g);break;case 2:j=(k(f,e)&lt;&lt;16)|(k(f,e+1)&lt;&lt;8);c.push(h.charAt(j&gt;&gt;18)+h.charAt((j&gt;&gt;12)&amp;63)+h.charAt((j&gt;&gt;6)&amp;63)+g);break&#125;return c.join(&quot;&quot;)&#125;;b.pay=function(d)&#123;var c=encodeURIComponent(a.encode(d));location.href=&quot;pay.htm?goto=&quot;+c&#125;;b.decode=function(c)&#123;return a.decode(decodeURIComponent(c))&#125;;window._AP=b&#125;)(); 2.支付宝生成签名 请求生成支付宝签名返回参数作为支付宝支付的参数。12345678910111213let params = new FormData();params.append(&apos;loginId&apos;, user.id); params.append(&apos;orderNo&apos;, orderNo); ApiClientUtil.post(ApiInfo.Alipay, params).then((json) =&gt; &#123; if(json.success) &#123; const gotoUrl=&apos;https://openapi.alipay.com/gateway.do?&apos;+ json.body; window._AP.pay(gotoUrl); &#125;else &#123; Alert.error(&apos;支付宝支付遇到问题，请重新尝试&apos;, &#123;position: &apos;top&apos;, offset: 40,onRouteClose: true, timeout: 2000&#125;); return; &#125;&#125;) 3.跳转到pay.htm这个页面当用户选择支付宝账户点击确认支付时，页面跳转到此页面提示用户打开浏览器，进而完成支付的页面，在新的浏览器网页中完成支付宝支付。请在菜单中选择在浏览器中打开,以完成支付…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; &quot;&gt; &lt;title&gt;支付提示&lt;/title&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot;/&gt; &lt;style&gt; *, :before, :after &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0) &#125; body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, form, fieldset, legend, input, textarea, p, blockquote, th, td &#123; margin: 0; padding: 0 &#125; table &#123; border-collapse: collapse; border-spacing: 0 &#125; fieldset, img &#123; border: 0 &#125; li &#123; list-style: none &#125; caption, th &#123; text-align: left &#125; q:before, q:after &#123; content: &quot;&quot; &#125; input:password &#123; ime-mode: disabled &#125; :focus &#123; outline: 0 &#125; html, body &#123; -webkit-touch-callout: none; touch-callout: none; -webkit-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; tap-highlight-color: transparent; height: 100%; margin: 0; padding: 0; text-align: center; font-size: 15px; font-weight: 300; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Lucida Grande&quot;, sans-serif &#125; a &#123; text-decoration: none &#125; body &#123; background: #F4F4F8 &#125; .weixin-tip &#123; display: none; -webkit-box-sizing: border-box; box-sizing: border-box; position: absolute; top: 15px; right: 20px; width: 265px; padding: 55px 0 0; text-align: left; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAACICAMAAABQgAwUAAAAMFBMVEUAAADY2NjY2NjY2NjY2NjY2NjY2NjY2NjX19fY2NjY2NjY2NjY2NjY2NjY2NjY2Njr/TvvAAAAD3RSTlMAxy89c9CdTRyG7lvcD7FzqbJAAAACFklEQVR42uWYy4rkMBAErZdlPdzx/3+7LAw0tH0Y2orDsnnyKQlSVaWytoc6xrEpigFoinUAIBnWABAE5woW9o6GPbGwI1jYGSzsgoV9goU9wMLe0bA7FnYCC7uBhV2wsE+wsAdY2AENGyzsBBZ2Q8MuWNgH94pLbgELO6Bhg4VdwcJuaNgTCzuChZ3Bwg5o2GBhV7CwdzTsjoUdwcLOYGEXLOwTLOwBFvaOht2xsBNY2I1f6lhaenvhrfpkAblab+k9b/OD0iuX2F9/x8D+7ZL2pmpbuj+6o3Vg//oWmPU9p65VkXL6+oIJ8S738nwj62Pb1lvHACH+fBs7sG59U3yrVD3rce3GVcp8qGkPAGTprQUYy6xfaE8i82b6S7/pfZnzdYQIHeOXdfYKpHoFcmrvWlM8RW+CDO8JMWoNM/+FeyB4UfMpL48g5qG1Iqc29YI3mqq2knXvEJu2onJoQy9ok4mkQZf/GjqitUvQyqN6SU8NOvOhHq25xNCWj6LFQdLiyKuaZWpxBC2OrFVHxdryElbQsVtBx6KN0qAd4a71yo610uxa2b0s5xg052I5p26d4MCqusZFwzrAnqQhSogSMnkNcr+GUS3kEKWS62NJFlNCToWLZpWMe14RReGqdjz2PfNECbkGbrQ/Nj5q5y7j8/HRTW5UhvHfA7Mdzitji8rfWsgX3gVZ91eO22odKed6LLf9A/sRnc74RV7lAAAAAElFTkSuQmCC) no-repeat right top; background-size: 45px 68px &#125; .weixin-tip-img &#123; display: none; padding: 110px 0 0 &#125; .weixin-tip-img::after &#123; display: block; margin: 15px auto; content: &apos; &apos;; background-size: cover &#125; .weixin-tip-img.iphone::after &#123; width: 150px; height: 150px; background-image: url(data:image/png;base64,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) &#125; .weixin-tip-img.android::after &#123; width: 173px; height: 240px; background-image: url(data:image/png;base64,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) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;J-weixin-tip weixin-tip&quot;&gt; &lt;div class=&quot;weixin-tip-content&quot;&gt; 请在菜单中选择在浏览器中打开,&lt;br/&gt; 以完成支付 &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;J-weixin-tip-img weixin-tip-img&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;br/&gt; &lt;a href=&quot;/&quot; name=&quot;&quot; style=&quot;font-size: 16px;color: green;&quot;&gt;支付完成，点此返回主页&lt;/a&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;ap.js&quot;&gt;&lt;/script&gt;&lt;script&gt; if (location.hash.indexOf(&apos;error&apos;) != -1) &#123; alert(&apos;参数错误，请检查&apos;); &#125; else &#123; var ua = navigator.userAgent.toLowerCase(); var tip = document.querySelector(&quot;.weixin-tip&quot;); var tipImg = document.querySelector(&quot;.J-weixin-tip-img&quot;); if (ua.indexOf(&apos;micromessenger&apos;) != -1) &#123; tip.style.display = &apos;block&apos;; tipImg.style.display = &apos;block&apos;; if (ua.indexOf(&apos;iphone&apos;) != -1 || ua.indexOf(&apos;ipad&apos;) != -1 || ua.indexOf(&apos;ipod&apos;) != -1) &#123; tipImg.className = &apos;J-weixin-tip-img weixin-tip-img iphone&apos; &#125; else &#123; tipImg.className = &apos;J-weixin-tip-img weixin-tip-img android&apos; &#125; &#125; else &#123; var getQueryString = function (url, name) &#123; var reg = new RegExp(&quot;(^|\\?|&amp;)&quot; + name + &quot;=([^&amp;]*)(\\s|&amp;|$)&quot;, &quot;i&quot;); if (reg.test(url)) return RegExp.$2.replace(/\+/g, &quot; &quot;); &#125;; var param = getQueryString(location.href, &apos;goto&apos;) || &apos;&apos;; location.href = param != &apos;&apos; ? _AP.decode(param) : &apos;pay.htm#error&apos;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 微信支付参考这个实现https://blog.csdn.net/wyk304443164/article/details/72845409 首先，用户选择微信支付，传入订单号。123456789101112131415161718let _that = this;Pay.done(order.bookNum, _that, 1, is_true =&gt; &#123; if (is_true) &#123; Alert.success(&apos;支付成功&apos;, &#123; position: &apos;top&apos;, offset: 40, onRouteClose: true, timeout: 1500, onClose: function () &#123; Utility.toPage(&apos;order&apos;); &#125; &#125;); &#125; else &#123; Alert.error(&apos;微信支付失败,请重新尝试&apos;, &#123;position: &apos;top&apos;, offset: 40,onRouteClose: true, timeout: 2000&#125;); return; &#125;&#125;); Pay组件支付实现支付过程中先由微信生成预支付信息，用户支付完成后执行成功提示等操作。同时，后台接口提供订单回调，修改订单状态业务等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &apos;react-jweixin&apos;; let Pay = &#123;&#125;;/** * 支付的回调 */let payCallback;/** * 开始支付--这个方法其实是从后台请求微信支付签名。成功继续，失败回调 * @param _order_id 传bookNum即可 * @param openid 微信公众号openid * @param _thisObj 传this即可 * @param _payType 支付类型--暂时只有微信 * @param _callback 回调 true or false */Pay.done = function (_order_id, _thisObj, _payType, _callback) &#123; let params = new FormData(); params.append(&apos;searchParam.bookNum&apos;, _order_id); params.append(&apos;searchParam.useFlag&apos;, 0); //0新商户 let openid = sessionStorage.getItem(&apos;openid&apos;); params.append(&apos;searchParam.openid&apos;, openid); if (typeof _callback === &quot;function&quot;) &#123; payCallback = _callback; &#125; ApiClientUtil.post(ApiInfo.PaySign, params).then((data) =&gt; &#123; if(data.head.success) &#123; this.doneResponse(data.body); &#125; &#125;).catch(() =&gt; &#123; payCallback(false); &#125;);&#125;;Pay.doneResponse = function (result) &#123; this.callPay(result);&#125;;Pay.callPay = function (code) &#123; if (typeof WeixinJSBridge === &quot;undefined&quot;) &#123; if (document.addEventListener) &#123; document.addEventListener(&apos;WeixinJSBridgeReady&apos;, this.jsApiCall, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(&apos;WeixinJSBridgeReady&apos;, this.jsApiCall); document.attachEvent(&apos;onWeixinJSBridgeReady&apos;, this.jsApiCall); &#125; &#125; else &#123; this.jsApiCall(code); &#125;&#125;;Pay.jsApiCall = function (code) &#123; WeixinJSBridge.invoke(&apos;getBrandWCPayRequest&apos;, code, function (res) &#123; if (!Utility.isNull(res) &amp;&amp; !Utility.isNull(res.err_msg) &amp;&amp; res.err_msg.indexOf(&apos;ok&apos;) &gt; 0) &#123; payCallback(true); &#125; else &#123; payCallback(false); &#125; &#125;);&#125;;export &#123; Pay as default &#125; 百度地图React-Bmap APIhttps://huiyan-fe.github.io/react-bmap/examples/ React-BMap只是利用了React组件的生命周期，来调用对应的百度地图JavaScript Api的方法，比如在componentDidMount和componentDidUpdate的时候在地图上添加覆盖物，componentWillUnmount的时候移除覆盖物，React对应的render渲染函数模块返回的是null。所以这里面地图相关的dom并不是react渲染的，真正创建地图之类的还是使用百度地图JavaScript Api，React-BMap只是利用了React组件的写法来封装百度地图JavaScript Api，使我们在使用React的时候能更方便的使用百度地图JavaScript Api。 基本设置申请百度地图账号首先去百度地图开放平台官网注册成为开发者. http://lbsyun.baidu.com/ 创建应用，获取移动账户秘钥。 安装npm install react-bmap 使用首页引入api &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=你的秘钥&quot;&gt;&lt;/script&gt; 引入组件 import { Map, Marker, Polyline, PointLabel, NavigationControl, MarkerList } from &apos;react-bmap&apos;; 具体实现实例基本地图标记 &lt;Map center={center} zoom=&quot;13&quot;&gt; { mapdata.map((item, index) =&gt; { if (isFlag==0) {// return ( &lt;Marker key={index} position={{lng: item.longitude,lat: item.latitude}} &gt; &lt;img style={{height:'3rem',width:'3rem'}} src={require(&apos;./images/air.png&apos;)} /&gt; &lt;div style={{fontSize:'0.8rem',color:'red',fontWeight: 'bold', width:'30rem'}}&gt;{item.num} &lt;/div&gt; &lt;/Marker&gt; ) } }) } &lt;NavigationControl /&gt; &lt;/Map&gt; 二、其他实例 1234567891011121314151617&lt;Map center=&#123;center&#125; zoom=&quot;17&quot; style=&#123;&#123;height: &apos;44rem&apos;&#125;&#125;&gt; &#123;/*&lt;PointLabel data=&#123;points&#125; /&gt;*/&#125; &#123;/*&lt;MarkerList data=&#123; points &#125; /&gt; */&#125; // 绘制标记点 &#123; markers.map((marker, index) =&gt; &#123; return ( &lt;Marker position=&#123;&#123;lng: marker.lng, lat: marker.lat&#125;&#125; offset=&#123;new window.BMap.Size(-15, -20)&#125;&gt; &lt;img src=&#123;require(&apos;./images/start_pos.png&apos;)&#125; onClick=&#123;(event) =&gt; this.handleClick(marker, event)&#125;/&gt; &lt;div id=&#123;&apos;marker&apos;+marker.porder&#125; style=&#123;&#123;fontSize:&apos;0.8rem&apos;,color:&apos;red&apos;, display:&apos;none&apos;&#125;&#125;&gt;&#123;marker.name&#125; &lt;/div&gt; &lt;/Marker&gt; ) &#125;) &#125; &lt;Polyline strokeColor=&apos;blue&apos; path=&#123; markers&#125; /&gt; //绘制线路 &lt;NavigationControl anchor=&quot;BMAP_ANCHOR_TOP_RIGHT&quot;/&gt; &lt;/Map&gt; 二维码组件APIhttps://www.npmjs.com/package/qrcode-react 安装npm install qrcode-react 使用引入组件 import QRCode from &apos;qrcode-react&apos;; 具体使用 &lt;Dialog type=&quot;ios&quot; show={this.state.showQR} buttons={this.state.passStyle.buttons} &gt; &lt;QRCode size={236} value={ qrstr } /&gt; &lt;/Dialog&gt; 可以设置logo，背景色，大小等。 react-s-alert组件安装npm install react-s-alert --save 使用在APP中引入样式与库文件 import Alert from &apos;react-s-alert&apos;; require(&apos;react-s-alert/dist/s-alert-default.css&apos;); require(&apos;react-s-alert/dist/s-alert-css-effects/genie.css&apos;); 具体使用 import Alert from &apos;react-s-alert&apos;; 警告提示12Alert.warning(&apos;请选择&apos;, &#123;position: &apos;top&apos;, offset: 40,onRouteClose: false, timeout: 1500&#125;); 错误提示 Alert.error(json.head.msg, {position: &apos;top&apos;, offset: 40,onRouteClose: false, timeout: 2000, onClose: function () { Utility.toPage(&apos;order&apos;); } }); onClose事件处理提示完之后的操作。 react-confirm-alert安装1npm install react-confirm-alert --save 使用引入相关样式与组件12import &#123; confirmAlert &#125; from &apos;react-confirm-alert&apos;; // Importimport &apos;react-confirm-alert/src/react-confirm-alert.css&apos; // Import css 以退票提示为例，在退票操作之前，询问用户是否确认退票(或者常见的删除前确认提示)。1234567891011121314confirmAlert(&#123; title: &apos;操作提示&apos;, message: &apos;退票将产生[&apos;+fee+&apos;]元手续费，您确认执行退款操作吗?&apos;, buttons: [ &#123; label: &apos;确认&apos;, onClick: () =&gt; this.refund() // 执行退票功能 &#125;, &#123; label: &apos;取消&apos;, onClick: () =&gt; console.log(&apos;取消了操作...&apos;) &#125; ]&#125;) 关于提示的样式可以根据API来设置或者到源码里改改界面颜色。APIhttps://www.npmjs.com/package/react-confirm-alert 其他做完这一个项目，对react以及相关组件了解了个大概，但现在看代码还是很杂很乱，看着闹心。为了赶进度，一些react特性没有好好地应用，还是原始的JavaScript方式。这次基本总结的同时也开始进行了项目重构，希望可以发挥react的优势，优化代码，优化调用以及实现方式等，争取年前完成。 文献资料从零搭建React全家桶框架教程https://github.com/brickspert/react-familyhttps://react.docschina.org/docs/thinking-in-react.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2019%2F01%2F21%2Fredux%2F</url>
    <content type="text"><![CDATA[ReduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。 1.应用中所有的状态都是以一个对象树的形式存储在一个单一的store中；2.当你想要改变应用的中的状态时，你就要dispatch一个action,这也是唯一的改变state的方法；3.通过编写reducer来维护状态，返回新的state,不直接修改原来数据； APIhttps://www.redux.org.cn/ 安装npm install --save redux 使用阮一峰老师关于 Redux 入门教程说法很好： 首先，并非所有的 React 应用程序都需要使用 Redux 的。 如果你不确定是否使用 Rudex ，那么你就是不需要的。如果你遇到了无法解决的难题，那么 Rudex 可能就是你需要的东西。 Redux 的设计思想很简单，就两句话: **1. 整个系统是一个状态机，视图与状态是一一对应的 所有的状态，保存在一个对象里面** State一个state对应着一个view，state改变，view跟着改变。 1234import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; getSlideData &#125; from &apos;actions/slides&apos;;@connect((state) =&gt; (&#123; slideData: state.slideData &#125;), &#123; getSlideData &#125;) connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) 官方API中说 It does not modify the component class passed to it; instead, it returns a new, connected component class for you to use. mapStateToProps(state, ownProps) 方法允许我们将store中的数据作为props绑定到组件中，只要store更新了就会调用mapStateToProps方法mapStateToProps返回的结果必须是object对象，该对象中的值将会更新到组件中。mapDispatchToProps(dispatch, [ownProps]) 第二个参数允许我们将action作为props绑定到组件中，mapDispatchToProps希望你返回包含对应action的object对象 Storestore是redux库中的createStore方法生成的对象，存储的是系统中的公有数据。 12import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;const finalCreateStore = applyMiddleware(...middleware)(createStore); applyMiddleware(科里化函数)主要是对redux的dispacth方法进行封装。 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 用户的行为通过store.dispatch()来出发进行更改state actionstore.dispatch触发action,定义触发的动作。 使用单独的模块或文件来定义 action type 常量并不是必须的，甚至根本不需要定义。对于小应用来说，使用字符串做 action type 更方便些。不过，在大型应用中把它们显式地定义成常量还是利大于弊的。 12345678910export const GET_SLIDES_LOADING = &apos;slides/loading&apos;;export const GET_SLIDES_SUCCESS = &apos;slides/success&apos;;export const GET_SLIDES_FAIL = &apos;slides/fail&apos;;export function getSlideData() &#123; return &#123; types: [GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL], promise: (client) =&gt; client.get(client.API.Slides, &#123; params: &#123; page: 1, rows: 10 &#125; &#125;) &#125;;&#125; 我们应该尽量减少在 action 中传递的数据 Reducer Reducers 指定了应用状态的变化如何响应 actions 并发送到 store. reducer就是一个纯函数，接收旧的 state 和 action，返回新的 state。 1234567891011121314151617181920212223242526import &#123; GET_SLIDES_LOADING, GET_SLIDES_SUCCESS, GET_SLIDES_FAIL &#125; from &apos;actions/slides&apos;;const initState = &#123; isLoading: false, slideData: &#123;&#125;, errorMsg: &apos;&apos;,&#125;;export default function reducer(state = initState, action) &#123; switch (action.type) &#123; case GET_SLIDES_FAIL: return &#123; ...state, isLoading: false, slideData: null, errorMsg: &apos;请求错误啦&apos;, &#125;; case GET_SLIDES_LOADING: return &#123; ...state, isLoading: true, slideData: null, errorMsg: &apos;请求中...&apos;, &#125;; case GET_SLIDES_SUCCESS: return &#123; ...state, isLoading: false, slideData: action.result.text, errorMsg: &apos;获取成功&apos;, &#125;; default: return state; &#125;&#125; 本次主要以一个首页轮播图的实现来实例整个流程。 Slider组件通过action把服务器响应(发生)请求送出来，获取轮播信息列表，reducer接收由store传入的请求action和旧的state((previousState, action) =&gt; newState)，将返回结果按自己的格式更新到新的state返回，组件更新UI进行展示。 1234case GET_SLIDES_SUCCESS: return &#123; ...state, isLoading: false, slides: action.result, errorMsg: &apos;获取成功&apos;, &#125;; 组件里获取数据展示 componentDidMount() { this.props.getSlideData().then((data) =&gt; { const nd = JSON.parse(data); if (nd.head.success) { this.setState({ slides: nd.body.rows }); } }, (err) =&gt; { console.log(err); }); setInterval(() =&gt; this.nextSlide(), 2000); }]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本指法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%8C%87%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[义甲佩戴老师说义甲相当于自己的指甲了要与自己的手指贴合，抹、托、打这三个指甲胶带缠绕靠近义甲底部。勾，大拇指缠绕比较特殊，要先把拇指放平，将义甲胶带部分与手指相平，指甲与手指的角度大概是120~130度差不多的位置。 另外，缠绕胶带的时候最好整齐，可能有点强迫症，但也是一个端正的开始。 基本手型右手自然弯曲，虎口处呈C状。弹奏时，指关节动而手不动，需要保持。左手三指并拢，大指与小指延展，手背微弯。无论左手还是右手整体都要是放松的姿势。 基本指法托大指指关节向外弹弦。 抹食指指关节向内弹弦。 勾中指指关节向内弹弦。 打名指指关节向内弹弦。 劈大指指关节向内弹弦。借助大指回拨的力度快速回拨。 大撮大指与中指，大指向外托，中指向里勾，同时弹奏两弦，一个8度。 小撮大指与食指，大指向外托，食指向里抹，同时弹奏两弦，在一个8度之内的都是小撮。 上划音右手先弹弦，左手按该弦。右手先动，左手再跟上，不要喧宾夺主。 下划音左手先按弦，右手弹奏。 回滑音上滑音与下滑音结合。右手弹奏，左手快速按下弹起。 定滑音规定音高的划音，1 12 6（12）之间有定滑音符号，可省略2音，直接跟上6。 颤音右手弹弦后，左手上下起伏按弦。弹奏颤音时，右手先动，左手跟上，注意左手手型。 持续颤音用的较少，比颤音时长长一些。 4和74音，按3音弦半拍，左手轻按弦。7音，按6音弦一拍，左手稍重按弦。 双托大指同时弹两弦。 双抹食指同时弹两弦。 连托大指向外连续弹弦。 连抹食指向内连续弹弦。 上刮奏食指由低音到高音连续弹弦。 下刮奏大指由高音到低音连续弹弦。 花指板前花 不占时值，装饰性的花指。正版花 占一定的时值(变奏) 8度双托是大撮加上连音一同弹奏，加上一个上划音。 其他遥指，大指连续反复托劈。琶音，单手或双手快速连续弹弦。泛音这三个或者其他未列的是尚未学习的，之后再学习过程中重新补充。 问题汇总1.弹奏力度不够，跟老师对比来的时候，明显感觉自己弹出的音太绵软。每个指法在练习的时候都有这个问题，需要多进行复盘，也可能吃多点就好了哈哈。2.一些按弦略有迟疑，在左手下滑音练习时，起手会慢。3.左手在按弦时，习惯性的单指(这是古琴的指法)，要三指并拢，大指与小指延展，手背微弯，整体是个放松的姿势。4.劈以及连托弹奏时，手型不自觉的会变动，同时还有力度问题，需要强化练习恢复过来。5.整体上手指灵活度还是不够，需要每日练习。6.指法符号要与指法对应起来。看到书上的指法符号手指能即时弹奏出来，现在存在看到一个符号要想半天才弹出来的情况。 最后，下次再去上课的时候注意老师弹奏时候的指法，先去模仿，再去练习，最后形成与自己契合的指法。 虽然课后做了笔记，总觉得之后会有丢失，这周重新做下汇总，把没想到的再补充完善下，基本指法比较简略，随着之后的学习再补充完善吧。 得良师春风化雨，有益友万事顺风。]]></content>
      <categories>
        <category>古筝</category>
      </categories>
      <tags>
        <tag>古筝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F01%2F11%2FGit%2F</url>
    <content type="text"><![CDATA[Git将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录1git add . 将缓存区内容添加到本地仓库1git commit -m &apos;注释&apos; 推送到远程服务器1git push 其他添加到暂存区时，出现很多untrack1git clean -f 之后，重新进行了添加，有个问题是将一些不需要的模块也上传了上去，于是做了清理以及重新添加提交等操作。 1git add * 查看当前仓库中文件的状态。 1git status 如果没有问题，进行提交到本地仓库，最后推送到远程服务器。 查看当前分支1git branch 更新代码到本地1git pull 此次将博客维护在了github上方便多台电脑操作，node_modules模块实在没必要上传维护，创建.gitignore文件,将不需要的文件夹配置在里面，被ignore的文件肯定不会被标上untracked，上面的问题就是显示红字untracked。在其他电脑上使用npm重新安装就可以，每次在更新博客时，要重新pull。 .gitignore文件配置1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 所有事情到最后都会是好事，如果还不是，那她还没到最后——约翰*列侬]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件通信方式总结]]></title>
    <url>%2F2019%2F01%2F09%2FReact%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[React组件通信方式父组件向子组件通信 父组件更新组件状态，通过props传递给子组件，子组件得到后进行更新。 Timer 是倒计时子组件，集成在了OrderPay父组件里，父组件向子组件传订单数据参数order对象。如下代码： &lt;Timer order={order} /&gt; //倒计时组件 在子组件里直接通过props获取父组件传递过来的参数，如下： let order = this.props.order;//订单详情 子组件向父组件通信 子组件更新组件状态，通过回调函数的方式传递给父组件。 子组件调用父组件通过props传给它的函数更新父组件state，进而完成子组件向父组件的通讯。 先看父组件1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;//导入子组件import Child from &apos;./child.js&apos;; class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; msg: &apos;父组件初始msg&apos; &#125; &#125; //父组件回调函数，更新state，进而更新父组件。 callback=(msg)=&gt;&#123; // setState方法,修改msg参数,值是由子组件传过来。 this.setState(&#123;msg&#125;); &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;子组件传值实验: &#123;this.state.msg&#125;&lt;/p&gt; &lt;Child callback=&#123;this.callback&#125; &gt;&lt;/Child&gt; &lt;/div&gt; ); &#125;&#125;export default App; 再看子组件 1234567891011121314151617181920212223import React from &quot;react&quot;;class Child extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; msg: &apos;子组件msg传值&apos; &#125; &#125; //通过props调用回调函数传值 trans=()=&gt;&#123; this.props.callback(this.state.msg); &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.trans&#125;&gt;激发trans事件，传值给父组件&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Child; 效果 跨级组件间通信 举个例子react-redux的，也是通过Context提供一个全局态的store。还有用户信息的使用，也可以通过context中传递数据。 通过props或state传值比较麻烦，context提供了一种组件之间共享数据的方式，可以避免数据在组件树上逐层传递，也就是用Context来实现跨层级的组件数据传递。 这篇文章写得非常好，看完就能理解context，上手实验更能理解透彻，毕竟最后都要应用起来。https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。 生产者123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;class App extends Component &#123; constructor(props)&#123; super(props); &#125; //生产者 //Context生产者，通过静态属性childContextTypes声明提供给子组件的Context对象的属性， static childContextTypes = &#123; propA: PropTypes.string &#125; //实例getChildContext方法，返回Context对象 getChildContext () &#123; return &#123; propA: &apos;propA&apos; &#125; &#125; render() &#123; return &lt;BppComponent /&gt; &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return &lt;CppComponent /&gt; &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 //子组件需要通过一个静态属性contextTypes声明后，才可以访问父组件Context对象的属性 static contextTypes = &#123; propA: PropTypes.string &#125; render () &#123; return( &lt;div&gt; &lt;p&gt;从生产者传递过来的属性A：&#123;this.context.propA&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default CppComponent; react升级后，Context的新API做了变更。 1234type Context&lt;T&gt; = &#123; Provider: Provider&lt;T&gt;, Consumer: Consumer&lt;T&gt;,&#125;; 消费者 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;const CommContext = React.createContext(&#123; a: &apos;aaaaa&apos;, b: &apos;bbbbb&apos;&#125;);class App extends Component &#123; //父组件 constructor(props)&#123; super(props); &#125; render() &#123; return( &lt;CommContext.Provider&gt; &lt;BppComponent /&gt; &lt;/CommContext.Provider&gt; ) &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return ( &lt;CppComponent&gt;context跨层级传参实验&lt;/CppComponent&gt; ); &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import PropTypes from &apos;prop-types&apos;/** * 通过静态方法React.createContext()创建一个Context对象， * 这个Context对象包含两个组件，&lt;Provider /&gt;和&lt;Consumer /&gt; */const CommContext = React.createContext(&#123; a: &apos;newaaaaa&apos;, b: &apos;newbbbbb&apos;&#125;);/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 render () &#123; return( &lt;CommContext.Consumer&gt; &#123; context =&gt; ( &lt;div&gt; &#123;this.props.children&#125; &lt;br/&gt; 参数a: &#123;context.a&#125; &lt;br/&gt; 参数b: &#123;context.b&#125; &lt;/div&gt; )&#125; &lt;/CommContext.Consumer&gt; ) &#125;&#125;export default CppComponent; 效果 其他使用方式构造方法： constructor(props, context) 生命周期： componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componetWillUpdate(nextProps, nextState, nextContext) 注入式的组件，类似背景、语言这种控制全局的变量，可使用context。 非嵌套组件间通信 非嵌套组件: 就是没有任何包含关系的组件,包括兄弟组件以及不再同一个父级的非兄弟组件。使用事件订阅，即一个发布者，一个或多个订阅者。 安装eventnpm install event -save 新建Evt.js，导入eventsimport {EventEmitter} from &apos;events&apos;; export default new EventEmitter(); 发布者通过emit事件触发方法，发布订阅消息给订阅者。发布者123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import Custom1 from &apos;./Custom1.js&apos;;import Custom2 from &apos;./Custom2.js&apos;;import emitter from &apos;./Evt.js&apos;;class App extends Component &#123; constructor()&#123; super(); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; //emit事件触发方法,过事件名称找对应的事件处理函数callCustom，将事件处理函数作为参数传入 emitter.emit(&apos;callCustom&apos;, &apos;Hello 我来发消息了&apos;); &#125; render() &#123; return( &lt;div&gt; &lt;br/&gt; &lt;button onClick = &#123;this.handleClick&#125;&gt;点击发布事件&lt;/button&gt; &lt;Custom1 /&gt; &lt;Custom2 /&gt; &lt;/div&gt; ) &#125;&#125;export default App; 订阅者Custom1 和 Custom2通过emitter.addListener(事件名称,函数名)方法，进行事件监听(订阅)。通过emitter.removeListener(事件名称,函数名)方法 ，进行事件销毁(取消订阅) 订阅者1 12345678910111213141516171819202122232425262728293031323334353637import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom1 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1收到消息--&apos;+msg &#125;); &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1即将销毁此消息--&apos;+ msg &#125;); &#125;) &#125; //订阅者1消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.state.msg&#125; &lt;/p&gt;) &#125;&#125;export default Custom1; 订阅者2 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom2 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2收到消息--&apos;+msg &#125;) &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2即将销毁此消息--&apos;+ msg &#125;) &#125;) &#125; //订阅者2消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;blue&apos;&#125;&#125;&gt;&#123;this.state.msg&#125;&lt;/p&gt;) &#125;&#125;export default Custom2; 运行效果如下：发布者发布消息前订阅者接收消息后 文献资料非嵌套组件通信详解https://blog.csdn.net/bbgdebb/article/details/79006277node.js源码解析-eventshttps://blog.csdn.net/leoleocs/article/details/50162065]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口问题以及解决方案汇总]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[接口问题以及解决方案汇总需求描述 省内接口转为全国统一接口，作为接口中转，主要是承上启下的作用。保持前端请求以及参数不变的情况下，业务逻辑集中处理；提供给第三方或者四方?!调用；当接口变更时只更改当前接口项目即可。 问题1java.net.URISyntaxException //Http Get请求报出此次错误。 问题原因： 第三方接口需要将参数部分进行编码后提交。 原接口进行了编码传到中转接口这里仍然需要获取并重新编码传给第三方。 解决办法： 重新进行编码URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;) 问题2关于接口请求参数JSON格式的重新封装问题。 问题原因： 请求参数param是json格式的，接收过来的参数不能直接toJSONString，编码后传给第三方 解决办法：1234if (map.containsKey(&quot;param&quot;)) &#123; JSONObject param = JSONObject.parseObject((String)map.get(&quot;param&quot;)); url = url + &quot;&amp;param=&quot; + URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;);&#125; 针对接口调用做简单的记录，方便今后查看。其实最好的框架是适合项目本身的，与高级或所谓低端无关，越是简单的反而更能解决问题，提升效率。 是非入耳君须忍，半作痴呆半作聋。]]></content>
      <categories>
        <category>接口</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题与配置优化]]></title>
    <url>%2F2019%2F01%2F03%2FHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[next主题配置https://hexo.io/themes/ 主题选择，本文是next主题安装配置以及优化。 安装与配置安装在博客根目录，打开git bash, git clone https://github.com/theme-next/hexo-theme-next themes / next 安装完毕后在站点目录下themes文件夹生成next主题文件夹。 站点开启主题在站点根目录设置主题：next next主题中文设置站点配置文件_config.yml language: zh-Hans Scheme 外观设置这里选择了双栏Pisces Muse黑白主调，大量留白。 Mist是Muse的紧凑版本，整洁有序的单栏外观 Gemini左侧网站信息及目录，块+片段结构布局 新增菜单设置第一步： hexo new page &apos;name&apos; # name分别为tags、categories、about 具体生成如下： hexo new page &apos;tags&apos; #创建tags标签子目录 hexo new page &apos;categories&apos; #创建categories分类子目录 hexo new page &apos;about&apos; #创建about关于子目录 第二步： 修改这tags和categories文件夹中的index.md，设置如下： 主题优化公益404将公益404一份在网页丢失时候。另外还放在了关于里面。 在网页丢失时候： 第一步：创建404页面 hexo new page 404 ; 第二步：在站点source文件夹下创建404.html，将如下代码粘贴进去，保存！ 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;]\&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网易云音乐注册一个网易账号，生成一个自己的一个歌单，加入自己喜欢的音乐。 在网易云插件里，嵌入iframe(可以根据自己设定调整，然后复制代码) hexo配置，在next主题下/layout/_macro/sidebar.swig文件里添加复制的代码即可。 配置显示在左侧栏中 点击桃心第一步： 在 /themes/next/source/js/src 文件夹下创建 clklove.js 将如下代码粘贴进去，保存！ 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 第二步： 在主题文件夹下 \themes\next\layout\_layout.swig文件末尾，引入创建的js文件，如下： 动态背景第一步：引入文件 123&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 第二步： 在next主题配置文件_config.yml设置 canvas_nest: true 搜索第一步：安装插件 npm install hexo-generator-searchdb --save 第二步：站点配置文件修改 12345search: path: search.xml field: post format: html limit: 10000 第三步：主题配置文件修改 12345# Local searchlocal_search: enable: true top_n_per_article: 1 unescape: false RSS第一步：安装插件 npm install hexo-generator-feed 第二步：站点配置 _config.yml配置文件添加以下代码： 1234567plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 第三步：主题配置 在themes目录下的_config.yml配置如下 rss: /atom.xml 进学致和，行方思远。——字严]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础]]></title>
    <url>%2F2018%2F12%2F29%2F%E4%BD%BF%E7%94%A8hexo%2BGitHub%2B%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[关于hexohttps://hexo.io/zh-cn/docs/ hexo官方文档连接地址 安装node和git 请自行从网上查找适合自己系统和版本进行安装。 node安装https://nodejs.org/zh-cn/ 自行配置Node.js环境 git安装git 下载 https://git-scm.com/download Hexo安装与启动部署npm install -g hexo-cli //hexo插件安装 hexo init blob //初始化hexo文件夹blob cd blob npm install hexo generate //可简写为hexo g hexo sever //可简写为hexo s 访问 http://localhost:4000 Hello World 上传GitHub安装github插件npm install hexo-deployer-git --save //安装插件 github注册以及配置(1) 没有GitHub的访问以下网站注册一个账户 https://github.com (2) 建立资源库，例如blob (3) 在hexo中配置该仓库地址 本地站点github相关配置找到hexo安装目录blob文件夹，在站点配置文件_config.yml里修改如下配置： deploy: type: git repository: git@github.com:你的Github账户/仓库.git branch: master 部署静态文件到github通过git bash部署到github上 hexo deploy //可简写为 hexo d 域名关联gitpage(1) 阿里云域名配置 在阿里云域名模块解析域名配置 将记录类型设置为CNAME； 记录值修改为 yourname.github.io 在hexo安装目录中找到source文件夹 新建CNAME文件，没有后缀。 将你的域名放在新建的CNAME文件中。 (2) GitHub Pages配置 在blob资源仓库中Setting里， 下拉找到GitHub Pages部分 配置 Custom domain，将你的域名填写进去，点击save。 其他//清除缓存 hexo clean //生成静态网页 hexo g //部署到git hexo d //本地服务启动 hexo s 比较简略，大体流程就是这些，个人觉得在自己动手查找过程会有更多的收获。 纸上得来终觉浅，觉知此事要躬行。——陆游]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
