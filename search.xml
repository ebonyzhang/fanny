<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React组件通信方式总结]]></title>
    <url>%2F2019%2F01%2F09%2Freact%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[React组件通信方式父组件向子组件通信 父组件更新组件状态，通过props传递给子组件，子组件得到后进行更新。 Timer 是倒计时子组件，集成在了OrderPay父组件里，父组件向子组件传订单数据参数order对象。如下代码： &lt;Timer order={order} /&gt; //倒计时组件 在子组件里直接通过props获取父组件传递过来的参数，如下： let order = this.props.order;//订单详情 子组件向父组件通信 子组件更新组件状态，通过回调函数的方式传递给父组件。 子组件调用父组件通过props传给它的函数更新父组件state，进而完成子组件向父组件的通讯。 先看父组件1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;//导入子组件import Child from &apos;./child.js&apos;; class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; msg: &apos;父组件初始msg&apos; &#125; &#125; //父组件回调函数，更新state，进而更新父组件。 callback=(msg)=&gt;&#123; // setState方法,修改msg参数,值是由子组件传过来。 this.setState(&#123;msg&#125;); &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;子组件传值实验: &#123;this.state.msg&#125;&lt;/p&gt; &lt;Child callback=&#123;this.callback&#125; &gt;&lt;/Child&gt; &lt;/div&gt; ); &#125;&#125;export default App; 再看子组件 1234567891011121314151617181920212223import React from &quot;react&quot;;class Child extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; msg: &apos;子组件msg传值&apos; &#125; &#125; //通过props调用回调函数传值 trans=()=&gt;&#123; this.props.callback(this.state.msg); &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.trans&#125;&gt;激发trans事件，传值给父组件&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Child; 效果 跨级组件间通信 举个例子react-redux的，也是通过Context提供一个全局态的store。还有用户信息的使用，也可以通过context中传递数据。 通过props或state传值比较麻烦，context提供了一种组件之间共享数据的方式，可以避免数据在组件树上逐层传递，也就是用Context来实现跨层级的组件数据传递。 这篇文章写得非常好，看完就能理解context，上手实验更能理解透彻，毕竟最后都要应用起来。https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。 生产者123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;class App extends Component &#123; constructor(props)&#123; super(props); &#125; //生产者 //Context生产者，通过静态属性childContextTypes声明提供给子组件的Context对象的属性， static childContextTypes = &#123; propA: PropTypes.string &#125; //实例getChildContext方法，返回Context对象 getChildContext () &#123; return &#123; propA: &apos;propA&apos; &#125; &#125; render() &#123; return &lt;BppComponent /&gt; &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return &lt;CppComponent /&gt; &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 //子组件需要通过一个静态属性contextTypes声明后，才可以访问父组件Context对象的属性 static contextTypes = &#123; propA: PropTypes.string &#125; render () &#123; return( &lt;div&gt; &lt;p&gt;从生产者传递过来的属性A：&#123;this.context.propA&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default CppComponent; react升级后，Context的新API做了变更。 1234type Context&lt;T&gt; = &#123; Provider: Provider&lt;T&gt;, Consumer: Consumer&lt;T&gt;,&#125;; 消费者 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import CppComponent from &apos;./Cpp.js&apos;;const CommContext = React.createContext(&#123; a: &apos;aaaaa&apos;, b: &apos;bbbbb&apos;&#125;);class App extends Component &#123; //父组件 constructor(props)&#123; super(props); &#125; render() &#123; return( &lt;CommContext.Provider&gt; &lt;BppComponent /&gt; &lt;/CommContext.Provider&gt; ) &#125;&#125;class BppComponent extends React.Component &#123; render () &#123; return ( &lt;CppComponent&gt;context跨层级传参实验&lt;/CppComponent&gt; ); &#125;&#125;export default App; 消费者 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import PropTypes from &apos;prop-types&apos;/** * 通过静态方法React.createContext()创建一个Context对象， * 这个Context对象包含两个组件，&lt;Provider /&gt;和&lt;Consumer /&gt; */const CommContext = React.createContext(&#123; a: &apos;newaaaaa&apos;, b: &apos;newbbbbb&apos;&#125;);/** * 第三层有A（生产者）层直接传递数据到此层C（消费者） */class CppComponent extends React.Component &#123; //消费者 render () &#123; return( &lt;CommContext.Consumer&gt; &#123; context =&gt; ( &lt;div&gt; &#123;this.props.children&#125; &lt;br/&gt; 参数a: &#123;context.a&#125; &lt;br/&gt; 参数b: &#123;context.b&#125; &lt;/div&gt; )&#125; &lt;/CommContext.Consumer&gt; ) &#125;&#125;export default CppComponent; 效果 其他使用方式构造方法： constructor(props, context) 生命周期： componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componetWillUpdate(nextProps, nextState, nextContext) 注入式的组件，类似背景、语言这种控制全局的变量，可使用context。 非嵌套组件间通信 非嵌套组件: 就是没有任何包含关系的组件,包括兄弟组件以及不再同一个父级的非兄弟组件。使用事件订阅，即一个发布者，一个或多个订阅者。 安装eventnpm install event -save 新建Evt.js，导入eventsimport {EventEmitter} from &apos;events&apos;; export default new EventEmitter(); 发布者通过emit事件触发方法，发布订阅消息给订阅者。发布者123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import PropTypes from &apos;prop-types&apos;;import Custom1 from &apos;./Custom1.js&apos;;import Custom2 from &apos;./Custom2.js&apos;;import emitter from &apos;./Evt.js&apos;;class App extends Component &#123; constructor()&#123; super(); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; //emit事件触发方法,过事件名称找对应的事件处理函数callCustom，将事件处理函数作为参数传入 emitter.emit(&apos;callCustom&apos;, &apos;Hello 我来发消息了&apos;); &#125; render() &#123; return( &lt;div&gt; &lt;br/&gt; &lt;button onClick = &#123;this.handleClick&#125;&gt;点击发布事件&lt;/button&gt; &lt;Custom1 /&gt; &lt;Custom2 /&gt; &lt;/div&gt; ) &#125;&#125;export default App; 订阅者Custom1 和 Custom2通过emitter.addListener(事件名称,函数名)方法，进行事件监听(订阅)。通过emitter.removeListener(事件名称,函数名)方法 ，进行事件销毁(取消订阅) 订阅者1 12345678910111213141516171819202122232425262728293031323334353637import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom1 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1收到消息--&apos;+msg &#125;); &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom1即将销毁此消息--&apos;+ msg &#125;); &#125;) &#125; //订阅者1消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.state.msg&#125; &lt;/p&gt;) &#125;&#125;export default Custom1; 订阅者2 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import emitter from &apos;./Evt.js&apos;;class Custom2 extends React.Component &#123; constructor()&#123; super(); this.state= &#123; msg:&apos;&apos; &#125; &#125; componentDidMount () &#123; //在组件挂载完成后声明一个自定义事件 emitter.addListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2收到消息--&apos;+msg &#125;) &#125;) &#125; componentWillUnmount () &#123; //组件销毁前移除事件监听 emitter.removeListener(&apos;callCustom&apos;, (msg) =&gt; &#123; this.setState(&#123; msg: &apos;Custom2即将销毁此消息--&apos;+ msg &#125;) &#125;) &#125; //订阅者2消息显示 render () &#123; return(&lt;p style=&#123;&#123;color:&apos;blue&apos;&#125;&#125;&gt;&#123;this.state.msg&#125;&lt;/p&gt;) &#125;&#125;export default Custom2; 运行效果如下：发布者发布消息前订阅者接收消息后 文献资料非嵌套组件通信详解https://blog.csdn.net/bbgdebb/article/details/79006277node.js源码解析-eventshttps://blog.csdn.net/leoleocs/article/details/50162065]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口问题以及解决方案汇总]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[接口问题以及解决方案汇总需求描述 省内接口转为全国统一接口，作为接口中转，主要是承上启下的作用。保持前端请求以及参数不变的情况下，业务逻辑集中处理；提供给第三方或者四方?!调用；当接口变更时只更改当前接口项目即可。 问题1java.net.URISyntaxException //Http Get请求报出此次错误。 问题原因： 第三方接口需要将参数部分进行编码后提交。 原接口进行了编码传到中转接口这里仍然需要获取并重新编码传给第三方。 解决办法： 重新进行编码URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;) 问题2关于接口请求参数JSON格式的重新封装问题。 问题原因： 请求参数param是json格式的，接收过来的参数不能直接toJSONString，编码后传给第三方 解决办法：1234if (map.containsKey(&quot;param&quot;)) &#123; JSONObject param = JSONObject.parseObject((String)map.get(&quot;param&quot;)); url = url + &quot;&amp;param=&quot; + URLEncoder.encode(param.toJSONString(),&quot;utf-8&quot;);&#125; 针对接口调用做简单的记录，方便今后查看。其实最好的框架是适合项目本身的，与高级或所谓低端无关，越是简单的反而更能解决问题，提升效率。 是非入耳君须忍，半作痴呆半作聋。今日听得别人八卦闲谈，笑而不语，仅此而已。]]></content>
      <categories>
        <category>接口</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题与配置优化]]></title>
    <url>%2F2019%2F01%2F03%2FHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[next主题配置https://hexo.io/themes/ 主题选择，本文是next主题安装配置以及优化。 安装与配置安装在博客根目录，打开git bash, git clone https://github.com/theme-next/hexo-theme-next themes / next 安装完毕后在站点目录下themes文件夹生成next主题文件夹。 站点开启主题在站点根目录设置主题：next next主题中文设置站点配置文件_config.yml language: zh-Hans Scheme 外观设置这里选择了双栏Pisces Muse黑白主调，大量留白。 Mist是Muse的紧凑版本，整洁有序的单栏外观 Gemini左侧网站信息及目录，块+片段结构布局 新增菜单设置第一步： hexo new page &apos;name&apos; # name分别为tags、categories、about 具体生成如下： hexo new page &apos;tags&apos; #创建tags标签子目录 hexo new page &apos;categories&apos; #创建categories分类子目录 hexo new page &apos;about&apos; #创建about关于子目录 第二步： 修改这tags和categories文件夹中的index.md，设置如下： 主题优化公益404将公益404一份在网页丢失时候。另外还放在了关于里面。 在网页丢失时候： 第一步：创建404页面 hexo new page 404 ; 第二步：在站点source文件夹下创建404.html，将如下代码粘贴进去，保存！ 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;]\&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网易云音乐注册一个网易账号，生成一个自己的一个歌单，加入自己喜欢的音乐。 在网易云插件里，嵌入iframe(可以根据自己设定调整，然后复制代码) hexo配置，在next主题下/layout/_macro/sidebar.swig文件里添加复制的代码即可。 配置显示在左侧栏中 点击桃心第一步： 在 /themes/next/source/js/src 文件夹下创建 clklove.js 将如下代码粘贴进去，保存！ 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 第二步： 在主题文件夹下 \themes\next\layout\_layout.swig文件末尾，引入创建的js文件，如下： 动态背景第一步：引入文件 123&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 第二步： 在next主题配置文件_config.yml设置 canvas_nest: true 搜索第一步：安装插件 npm install hexo-generator-searchdb --save 第二步：站点配置文件修改 12345search: path: search.xml field: post format: html limit: 10000 第三步：主题配置文件修改 12345# Local searchlocal_search: enable: true top_n_per_article: 1 unescape: false RSS第一步：安装插件 npm install hexo-generator-feed 第二步：站点配置 _config.yml配置文件添加以下代码： 1234567plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 第三步：主题配置 在themes目录下的_config.yml配置如下 rss: /atom.xml 进学致和，行方思远。——字严]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础]]></title>
    <url>%2F2018%2F12%2F29%2F%E4%BD%BF%E7%94%A8hexo%2BGitHub%2B%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[关于hexohttps://hexo.io/zh-cn/docs/ hexo官方文档连接地址 安装node和git 请自行从网上查找适合自己系统和版本进行安装。 node安装https://nodejs.org/zh-cn/ 自行配置Node.js环境 git安装git 下载 https://git-scm.com/download Hexo安装与启动部署npm install -g hexo-cli //hexo插件安装 hexo init blob //初始化hexo文件夹blob cd blob npm install hexo generate //可简写为hexo g hexo sever //可简写为hexo s 访问 http://localhost:4000 Hello World 上传GitHub安装github插件npm install hexo-deployer-git --save //安装插件 github注册以及配置(1) 没有GitHub的访问以下网站注册一个账户 https://github.com (2) 建立资源库，例如blob (3) 在hexo中配置该仓库地址 本地站点github相关配置找到hexo安装目录blob文件夹，在站点配置文件_config.yml里修改如下配置： deploy: type: git repository: git@github.com:你的Github账户/仓库.git branch: master 部署静态文件到github通过git bash部署到github上 hexo deploy //可简写为 hexo d 域名关联gitpage(1) 阿里云域名配置 在阿里云域名模块解析域名配置 将记录类型设置为CNAME； 记录值修改为 yourname.github.io 在hexo安装目录中找到source文件夹 新建CNAME文件，没有后缀。 将你的域名放在新建的CNAME文件中。 (2) GitHub Pages配置 在blob资源仓库中Setting里， 下拉找到GitHub Pages部分 配置 Custom domain，将你的域名填写进去，点击save。 其他//清除缓存 hexo clean //生成静态网页 hexo g //部署到git hexo d //本地服务启动 hexo s 比较简略，大体流程就是这些，个人觉得在自己动手查找过程会有更多的收获。纸上得来终觉浅，觉知此事要躬行。——陆游]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
